#
# Started from zle or from command line
#

[[ "${ZUI[stdlib_sourced]}" != "1" ]] && source "${ZUI_REPO_DIR}/stdlib.lzui"

# Cleanup $ZUI hash runtime data
-zui_stdlib_cleanup

[[ -o interactivecomments ]] && ZUI[INTERACTIVE_COMMENTS]="1" || ZUI[INTERACTIVE_COMMENTS]="0"
[[ -o promptsubst ]] && ZUI[PROMPT_SUBST]="1" || ZUI[PROMPT_SUBST]="0"

emulate -LR zsh
setopt extendedglob typesetsilent warncreateglobal

[[ "${ZUI[PROMPT_SUBST]}" = "1" ]] && setopt promptsubst

ZUI[app]="zui-test"

##
## Main code
##

# Measure and limit generation time
typeset -F SECONDS=0.0
local -F start_seconds

#
# Actions
#

-zui_external_test_action_1() {
    local var_name="module${2}_extra_line"
    : ${(P)var_name::=Function set this line, regeneration used it}

    # Request regeneration - module ID
    # and regeneration argument (empty)
    reply=( ",module${2}," "" )
}

-zui_external_anchor_action_2() {
    print "[Module1] anchor button - I've jumped even though list has been restarted!"
}

#
# Internal actions
#

# Anchor internal action - data1 is index in time
# of creation of the anchor (it an be changed via
# on-the-fly updates submitted by stdlib function
# -zui_stdlib_submit_list_update)
-zui_test_internal_action_1() {
    local id="$1" line="$2" module="$3"

    if [[ "$module" = "2" ]]; then
        zcurses bg "status" "green/black"
        # This is internal zui-list variable,
        # accessible because internal actions
        # are called from within the list
        bold="+bold"
    elif [[ "$module" = "3" ]]; then
        zcurses bg "status" "white/blue"
    fi
}

-zui_test_internal_action_2() {
    local id="$1" module="$2" var_name previous_size

    reply=( ); reply2="0"; reply3=( ); reply4=( )

    -zui_test_module2_generator $module

    # Setting the following will also pass the new
    # content to regeneration-path, if only this
    # specific module 2 will not be regenerated
    # (so some other, e.g. via REGENERATE=,module1,)

    var_name="module${module}_output"
    : ${(PA)var_name::="${reply[@]}"}
    var_name="module${module}_size"
    previous_size="${(P)var_name}"
    : ${(PA)var_name::=$reply2}
    var_name="module${module}_nonselectables"
    : ${(PA)var_name::="${reply3[@]}"}
    var_name="module${module}_hops"
    : ${(PA)var_name::="${reply4[@]}"}

    # Submit on-the-fly list update.
    # The same data.
    var_name="module${module}_global_index"
    -zui_stdlib_submit_list_update "${(P)var_name}" "$(( ${(P)var_name} + previous_size - 1 ))" "${reply[@]}"
    -zui_stdlib_submit_nonselectables "${reply3[@]}"
    -zui_stdlib_submit_hops "${reply4[@]}"

    reply=( ); reply2="0"; reply3=( ); reply4=( )
}

#
# Other callbacks
#

# Optional, unset explicitly if unused
# It generates additional status text, displayed after
# "Current #...", from data of highlighted button
-zui-standard-status-callback() {
    local id data1 data2 data3 data4 text handler
    id="$1"
    data3="$3"
    handler="$7"

    id="${${${${${id#zuiiaction}#zuiaction}#zuicheckbox}#zuieanchor}#zuianchor}"

    reply=( "My id: $id" " My data: $data3" " My handler:" " $handler" )
}

#
# Generators for module
#

# Generator for module 1
-zui_test_module1_generator() {
    reply=( )
    # IDs of anchors have own namespace
    -zui_stdlib_anchor "regenerate1" "4" "" ",module${1}," "${RANDOM}$((RANDOM%2))" "[${ZUI_MAGENTA}Regenerate${ZUI_MAGENTA_E}]"
    -zui_stdlib_rc_button "regenerate2" "$1" "" "" "" "${ZUI_MAGENTA}Regenerate${ZUI_MAGENTA_E}" -zui_external_test_action_1
    -zui_stdlib_rc_button "regenerate3" "$1" "" ",module$(( $1 + 1 ))," "" "${ZUI_MAGENTA}Regenerate${ZUI_MAGENTA_E}"

    # Passed user data
    local user_data=${2:+ \[Obtained regeneration user data: $2\]}

    # Content
    reply=(
            "Hello World from ${ZUI_GREEN}module ${1}${ZUI_GREEN_E}"
            "${reply[1]} this section via ${ZUI_YELLOW}list_restart${ZUI_YELLOW_E} and ${ZUI_CYAN}external_anchor${ZUI_CYAN_E}${user_data}"
            "${reply[2]} this section via ${ZUI_YELLOW}list_restart${ZUI_YELLOW_E} and ${ZUI_CYAN}function_call${ZUI_CYAN_E}"
            "${reply[3]} ${ZUI_RED}NEXT${ZUI_RED_E} section via ${ZUI_YELLOW}list_restart${ZUI_YELLOW_E} and ${ZUI_CYAN}raw_link${ZUI_CYAN_E}"
            "Random number: $RANDOM$((RANDOM%2))"

            # This is set in -zui_external_test_action_1
            $module1_extra_line
            )
    # Content count
    reply2=${#reply[@]}
    # Non-selectables
    reply3=( 1 )
    # Hops
    reply4=( 1 )
}

# Generator for module 2
-zui_test_module2_generator() {
    local append_third

    # Second instance of this content?
    if [[ "$1" = "3" && "$total_module_limit" -eq 3 ]]; then
        reply=( )
        -zui_stdlib_rc_button "append_third" "$1" "" ",module${1},module$(( $1 + 1 ))," "" "${ZUI_MAGENTA}Append third!${ZUI_MAGENTA_E}" "(( total_module_limit ++ ))"
        append_third="${reply[1]}"
    fi

    local regenerate
    if [[ "$1" = "2" ]]; then
        reply=( )
        # IDs of anchors have own namespace
        -zui_stdlib_rc_button "regenerate4" "$1" "" "" "" "${ZUI_MAGENTA}Regenerate${ZUI_MAGENTA_E}" -zui_test_internal_action_2
        regenerate="${reply[1]} this section on-the-fly, ${ZUI_YELLOW}without${ZUI_YELLOW_E} list restart"
    fi

    if [[ "$1" = "2" ]]; then
        local rand_line="Random number: ${ZUI_YELLOW}$RANDOM$((RANDOM%2))${ZUI_YELLOW_E}"
    else
        local rand_line="Random number: $RANDOM$((RANDOM%2))"
    fi
    # Content
    reply=(
        "I'm the same generator called ${ZUI_CYAN}#$(( $1 - 1 ))${ZUI_CYAN_E} time"
        "${ZUI_GREEN}I'm not selectable${ZUI_GREEN_E}"
        $regenerate
        "$rand_line"
        $append_third
    )
    # Content count
    reply2=${#reply[@]}
    # Non-selectables
    reply3=( 2 )
    # Hops
    reply4=( 1 )
}

#
# Business logic follows
#

local curcontext=":zle:$WIDGET"
local MATCH; local -i MBEGIN MEND
local -a match mbegin mend

#
# General zstyles
#

#
# Variables
#

# Replies from generation modules
local -a reply reply3 reply4
integer reply2

# Module counter - used to declare parameters
# of given module (they are distinct only in
# counter embedded in them)
local module

# Used to access parameters via name
local var_name

# Used in e.g. for loops as index
integer i

# A variable used for demonstration purposes
local module1_extra_line

# Maximum number of modules to generate,
# the dynamic ones will saturate that value
integer total_module_limit=3

###
### REGENERATION REQUEST LOOP ###
###

# Set REGENERATE_ALWAYS to e.g. ,module3,
# to always regenerate third module
local REGENERATE="initial" REGENERATE_ARG="" REGENERATE_ALWAYS=""

while (( 1 )); do

# Measure generation time
start_seconds=$SECONDS

#
# Common regeneration block
#

if [[ "$REGENERATE" = "initial" || "$REGENERATE" = *,all,* ]]
then
    :
fi

#
# Module 1
#

module=1

if [[ "$REGENERATE" = "initial" || "$REGENERATE" = *,module${module},* || "$REGENERATE" = *,all,* ]]; then
    reply=( ); reply2="0"; reply3=( ); reply4=( )

    # Module 1
    local -a module${module}_output module${module}_nonselectables module${module}_hops
    local -a prev_module${module}_nonselectables prev_module${module}_hops
    integer module${module}_size prev_module${module}_size

    -zui_test_module1_generator $module $REGENERATE_ARG

    var_name="module${module}_output"
    : ${(PA)var_name::="${reply[@]}"}
    var_name="module${module}_size"
    : ${(PA)var_name::=$reply2}
    var_name="module${module}_nonselectables"
    : ${(PA)var_name::="${reply3[@]}"}
    var_name="module${module}_hops"
    : ${(PA)var_name::="${reply4[@]}"}
fi

#
# Automatic Module 2 & Module 3
#

for (( i=2; i <= total_module_limit; i ++ )); do

    module=$i

    if [[ "$REGENERATE" = "initial" || "$REGENERATE" = *,module${module},* || "$REGENERATE" = *,all,* ]]; then
        reply=( ); reply2="0"; reply3=( ); reply4=( )

        local -a module${module}_output module${module}_nonselectables module${module}_hops
        local -a prev_module${module}_nonselectables prev_module${module}_hops
        integer module${module}_size prev_module${module}_size

        -zui_test_module2_generator $module

        var_name="module${module}_output"
        : ${(PA)var_name::="${reply[@]}"}
        var_name="module${module}_size"
        : ${(PA)var_name::=$reply2}
        var_name="module${module}_nonselectables"
        : ${(PA)var_name::="${reply3[@]}"}
        var_name="module${module}_hops"
        : ${(PA)var_name::="${reply4[@]}"}
    fi

done

#
# Store all results into OUTPUT, ZUILIST_NONSELECTABLE_ELEMENTS, ZUILIST_HOP_INDICES
#

typeset -ga ZUILIST_NONSELECTABLE_ELEMENTS ZUILIST_HOP_INDICES
ZUILIST_NONSELECTABLE_ELEMENTS=()
ZUILIST_HOP_INDICES=()

local -a OUTPUT output nonselectables hops
local -a prev_nonselectables prev_hops
local -a anchors
local n
integer LINE_COUNT size

OUTPUT=( )
LINE_COUNT=0
anchors=( )

for (( i = 1; i <= 1000; i ++ )); do
    n="module$i"

    # Check if there are any modules
    var_name="${n}_output"
    [[ "${(P)+var_name}" = "0" ]] && break

    # Get output
    output=( "${(PA@)var_name}" )

    # Get output size
    var_name="${n}_size"
    size="${(P)var_name}"

    # Get nonselectables
    var_name="${n}_nonselectables"
    nonselectables=( "${(PA@)var_name}" )

    # Get hops
    var_name="${n}_hops"
    hops=( "${(PA@)var_name}" )

    # Get previous nonselectables
    var_name="prev_${n}_nonselectables"
    prev_nonselectables=( "${(PA@)var_name}" )

    # Get previous hops
    var_name="prev_${n}_hops"
    prev_hops=( "${(PA@)var_name}" )

    if (( size > 0 )); then
        OUTPUT+=( "" )
        LINE_COUNT+=1
        # + 1 for the anchors at top
        ZUILIST_NONSELECTABLE_ELEMENTS+=( "$(( LINE_COUNT + 1 ))" )
    fi

    # Translate returned indices to global ones
    # The + 1 is for anchors at the top
    nonselectables=( "${nonselectables[@]//(#b)([[:digit:]]##)/$(( ${match[1]} + LINE_COUNT + 1 ))}" )
    hops=( "${hops[@]//(#b)([[:digit:]]##)/$(( ${match[1]} + LINE_COUNT + 1 ))}" )

    # Add translated, current hops and nonselectables
    ZUILIST_NONSELECTABLE_ELEMENTS+=( "${nonselectables[@]}" )
    ZUILIST_HOP_INDICES+=( "${hops[@]}" )

    # Also store the indices into prev_* arrays
    var_name="prev_${n}_nonselectables"
    : "${(PA)var_name::=${nonselectables[@]}}";
    var_name="prev_${n}_hops"
    : "${(PA)var_name::=${hops[@]}}";
    var_name="prev_${n}_size"
    : "${(P)var_name::=${size}}";

    # Create anchors for selected sections
    reply=( )
    if [[ "$i" = "1" ]]; then
        # First argument of -zui_stdlib_anchor is
        # reserved to index to jump to. Second
        # argument, in case of automatically (in
        # a loop) generated modules can be required
        # to be index of the module ($i of this
        # loop)
        [[ -n "${hops[1]}" ]] && -zui_stdlib_anchor "amain$i" "${hops[1]}" "$i" "" "" "[${ZUI_MAGENTA}Module1${ZUI_MAGENTA_E}]" -zui_external_anchor_action_2
    elif [[ "$i" -ge "2" && "$i" -le "3" ]]; then
        [[ -n "${hops[1]}" ]] && -zui_stdlib_anchor "amain$i" "${hops[1]}" "$i" "" "" "[${ZUI_CYAN}Module${i}${ZUI_CYAN_E}]" -zui_test_internal_action_1
    else
        [[ -n "${hops[1]}" ]] && -zui_stdlib_anchor "amain$i" "${hops[1]}" "$i" "" "" "[${ZUI_YELLOW}Module${i}${ZUI_YELLOW_E}]" -zui_test_internal_action_1
    fi
    anchors+=( "${reply[@]}" )

    # Store where in the list module is
    # located, via typical "moduleX_..."
    # variable
    local ${n}_global_index
    var_name="${n}_global_index"
    # + 1 for anchors, + 1 for "next future line"
    : ${(P)var_name::=$(( LINE_COUNT + 1 + 1 ))}

    OUTPUT+=( "${output[@]}" )
    LINE_COUNT+=size
done

# Reset regeneration variables and prev_current_project
REGENERATE=""
REGENERATE_ARG=""

#
# Generation time
#

local generation_time="$(( SECONDS - start_seconds ))"
ZUI[GENERATION_TIME]="${generation_time[1,4]}"

#
# Invoke the list, handle outcome
#

ZUILIST_HOP_INDICES+=( 1 ) # jump to anchors
ZUILIST_NONSELECTABLE_ELEMENTS+=( $(( 1 + ${#OUTPUT} + 2 )) )
local ZUILIST_WRAPPER_BIT=""
zui-usetty-wrapper zui-list-wrapper "${anchors[*]}" "${OUTPUT[@]}" "" "${ZUI_YELLOW}Fine grained list (re-)generation time: $generation_time${ZUI_YELLOW_E}"

if [ -z "$ZUILIST_WRAPPER_BIT" ]; then
    zle && { zle .redisplay; zle .reset-prompt; }

    # Cleanup $ZUI hash runtime data
    -zui_stdlib_cleanup

    return 0
fi

# ID, data1, data2, data3, data4
if -zui_stdlib_decode_hyperlink "$ZUILIST_WRAPPER_BIT"; then
    local id="${reply[1]}" data1="${reply[2]}" data2="${reply[3]}" data3="${reply[4]}" data4="${reply[5]}"

    integer call_hook=0
    if [[ "$id" = zuieanchor* ]]; then
        ZUILIST_CURRENT_IDX="${ZUI[$id]-$data1}"
        ZUILIST_CURRENT_SEGMENT=1
        id="zuiaction${id#zuieanchor}"
        call_hook=1
    elif [[ "$id" = zuiaction* ]]; then
        call_hook=1
    fi

    if [[ $call_hook -gt 0 && -n "${ZUI[$id]}" ]]; then
        reply[1]="${${${${${reply[1]#zuiiaction}#zuiaction}#zuicheckbox}#zuieanchor}#zuianchor}"
        # Call the handler with all hyper-link
        # data or eval code, not using the data
        if [[ "${ZUI[$id]}" = *(=|\(\()* ]]; then
            eval "${ZUI[$id]}"

            # Does in-line code set reply?
            if [[ "${ZUI[$id]}" = *reply=* ]]; then
                REGENERATE="${reply[1]}"
                REGENERATE_ARG="${reply[2]}"
            else
                REGENERATE="$data3"
                REGENERATE_ARG="$data4"
            fi
        else
            "${ZUI[$id]}" "${reply[@]}"

            # Handler can request regeneration
            REGENERATE="${reply[1]}"
            REGENERATE_ARG="${reply[2]}"
        fi

    else
        # Without handler regeneration can be requested
        # only by link itself, by data3 and data4 of the
        # link (data1 can be used by anchor - hold target
        # line number, while data2 optionally can hold
        # module number)
        REGENERATE="$data3"
        REGENERATE_ARG="$data4"
    fi

    REGENERATE+="$REGENERATE_ALWAYS"
fi

### REGENERATION REQUEST LOOP ###
done

# Cleanup $ZUI hash runtime data
-zui_stdlib_cleanup

return 0

# vim:ft=zsh
