#
# Library file (*.lzui)
#
# System (internal) functions
#

ZUI[syslib_sourced]="1"

# FUNCTION: -zui_syslib_get_tfield_cursor_boundaries {{{
# Gets cursor minimum and maximum x position for
# given line and given (via id) text field. Stores
# them into two parameters given by name. Testable,
# returns if the cursor positions could have been
# established.
#
# Example call:
# -zui_syslib_get_tfield_cursor_boundaries "cidx_start" "cidx_end" "${list[10]}" "${reply[@]}"
#
# $1 - output parameter name - cursor start index
# $2 - output parameter name - cursor end index
# $3 - current $list (zui-list working variable) element
# $4, ..., $11 - decoded __text field
function -zui_syslib_get_tfield_cursor_boundaries() {
    local __out1="$1" __out2="$2" __elem="$3" __id="$4"
    local -a __output

    zui-process-buffer "$__elem"

    integer __i __size="${#ZUI_PB_WORDS}" __idx=0
    local __seg __text

    for (( __i=1; __i <= __size; __i ++ )); do
        __idx+="${#ZUI_PB_SPACES[__i]}"
        __seg="${ZUI_PB_WORDS[__i]}"
        if -zui_stdlib_is_hyperlink "$__seg"; then
            __text="${__seg//$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\02'/}"
            -zui_util_strip_codes "$__text"
            __idx+="${#REPLY}"
        elif -zui_stdlib_decode_text_field "$__seg" __output; then
            if [[ "$__id" = "${__output[1]}" ]]; then
                # Add characters that precede
                if [[ "$__seg" = (#b)(*)$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\02']#$'\02'* ]]; then
                    __idx+=${mend[1]}
                fi
                # Minimum x position
                : ${(P)__out1::=$__idx}

                __text="${(P)__output[5]}"
                __text="${__text[${(P)__output[4]},-1]}"
                __text="${__text[1,${(P)__output[3]}]}"
                __idx+="${#__text}"
                # Maximum x position
                : ${(P)__out2::=$__idx}
                return 0
            else
                # Add characters that precede and follow
                if [[ "$__seg" = (#b)(*)$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\02']#$'\02'(*) ]]; then
                    __idx+=${mend[1]}+${#match[2]}
                fi
                __idx+="${(P)__output[3]}"
            fi
        elif -zui_stdlib_decode_list_box "$__seg" __output; then
            if [[ "$__id" = "${__output[1]}" ]]; then
                # Add characters that precede
                if [[ "$__seg" = (#b)(*)$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\02']#$'\02'* ]]; then
                    __idx+=${mend[1]}
                fi

                # Minimum x position
                : ${(P)__out1::=$__idx}

                # Just take width
                __idx+="${__output[2]}"

                # Maximum x position
                : ${(P)__out2::=$__idx}
                return 0
            else
                # Add characters that precede and follow
                if [[ "$__seg" = (#b)(*)$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\02']#$'\02'(*) ]]; then
                    __idx+=${mend[1]}+${#match[2]}
                fi
                __idx+="${(P)__output[3]}"
            fi
        else
            -zui_util_strip_codes "$__seg"
            __idx+="${#REPLY}"
        fi
    done

    __idx+="${#ZUI_PB_SPACES[__i]}"

    # Store incorrect data
    : ${(P)__out1::=$__idx}
    : ${(P)__out2::=$__idx}

    return 1
} # }}}

# FUNCTION: -zui_syslib_gather_lanchors  {{{
# Appends mod${1}_ice${2}_lanchors into array given by name
#
# $1 - module index
# $2 - instance index
# $3 - target array name
function -zui_syslib_gather_lanchors() {
    local __var_name1="mod${1}_ice${2}_lanchors" __var_name2="${3-reply}"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "-zui_stdlib_gather_lanchors must obtain module and instance indices"
        return 1
    fi

    # Append and store
    local -a __output
    __output=( "${(P@)__var_name2}" "${(P@)__var_name1}" )

    : ${(PA)__var_name2::=${__output[@]}}
} # }}}

# FUNCTION: -zui_syslib_decode_list_update {{{
# Deserializes on-the-fly update package.
# To be used rather only internally.
#
# $1 - the package
# $2 - optional target parameter name
function -zui_syslib_decode_list_update() {
    local -a __segments
    [[ -n "$1" ]] && __segments=( "${(z@)1}" ) || __segments=( "" "" 0 0 )
    local __var_name="${2-reply}"

    : ${(PA)__var_name::="${(Q)__segments[@]}"}
} # }}}

# FUNCTION: -zui_syslib_decode_hops {{{
# Deserializes on-the-fly hops substitution.
# For internal usage.
#
# $1 - the hops' package
# $2 - optional target parameter name
function -zui_syslib_decode_hops() {
    local -a __hops
    [[ -n "$1" ]] && __hops=( "${(z@)1}" ) || __hops=( )
    local __var_name="${2-reply}"
    : ${(PA)__var_name::=${(Q)__hops[@]}}
} # }}}

# FUNCTION: -zui_syslib_decode_nonselectables {{{
# Deserializes on-the-fly nonselectables
# substitution. For internal usage.
#
# $1 - the nonselectables' package
# $2 - optional target parameter name
function -zui_syslib_decode_nonselectables() {
    local -a __nonselectables
    [[ -n "$1" ]] && __nonselectables=( "${(z@)1}" ) || __nonselectables=( )
    local __var_name="${2-reply}"
    : ${(PA)__var_name::="${(Q)__nonselectables[@]}"}
} # }}}

# FUNCTION: -zui_syslib_decode_lanchors {{{
# Deserializes on-the-fly local anchors.
# For internal usage.
#
# $1 - the anchors' package
# $2 - optional target parameter name
function -zui_syslib_decode_lanchors() {
    local -a __lanchors
    [[ -n "$1" ]] && __lanchors=( "${(z@)1}" ) || __lanchors=( )
    local __var_name="${2-reply}"
    : ${(PA)__var_name::="${(Q)__lanchors[@]}"}
} # }}}

# vim:ft=zsh
