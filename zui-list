# $1 - main window name
# $2, $3 - width and height of the window
# $4 - optional status window name
# $5, $6 - width and height of the window
#
# $ZUILIST_NONSELECTABLE_ELEMENTS - array of indexes (1-based) that cannot be selected
# $ZUILIST_HOP_INDICES - array of indexes (1-based) jumpable with [, ]
#
# $REPLY is the output variable - contains index (1-based) or -1 when no selection
# $reply (array) is the second part of the output - use the index (REPLY) to get selected element
#
# This function outputs a list of elements that can be navigated with keyboard.
# Besides vertical navigation, it does horizontal navigation over elements of line.
# Uses curses library.

emulate -LR zsh

setopt typesetsilent extendedglob noshortloops
[[ "${ZUI[PROMPT_SUBST]}" = "1" ]] && setopt promptsubst

zmodload zsh/curses
zmodload zsh/terminfo 2>/dev/null

trap "REPLY=-2; reply=(); return" TERM INT QUIT

[[ "${ZUI[stdlib_sourced]}" != "1" ]] && source "${ZUI_REPO_DIR}/lib/stdlib.lzui"

# Outputs message in color, restores default color
-zui_curses_colmsg() {
    zcurses attr "$wname_status" "$1/$background"
    zcurses string "$wname_status" "$2"
    zcurses attr "$wname_status" "$colorpair"
}

# Outputs a message in the bottom of the screen
# "[UNIQ]", "Text", "[Grep string]", "Generation time", "$reply[@]" from callback
-zui_list_status_msg() {
    # -1 for border, -1 for 0-based indexing
    zcurses move "$wname_status" 2 0; zcurses clear "$wname_status" eol
    zcurses move "$wname_status" 1 2; zcurses clear "$wname_status" eol

    [[ -n "$4" ]] && {
        1="" 2="" 3=""
        -zui_curses_colmsg yellow "$4 "
        (( status_msg_strlen += ${#4} + 1 ))
    }

    local txt index
    status_msg_strlen=0 # status_msg_strlen is localized in caller
    for txt in $1 $2 $3; do
        zcurses string "$wname_status" "$txt "
        (( status_msg_strlen += ${#txt} ))
    done

    local -a col
    col=( cyan green red magenta yellow blue )
    for txt in "$5" "$6" "$7" "$8" "$9" "$10"; do
        (( ++ index ))
        [[ -n "$txt" ]] && { 
            -zui_curses_colmsg "${col[index]}" "$txt"
            (( status_msg_strlen += ${#txt} ))
        }
    done
}

# $1 is window name, $2 is the expected cursor state (0 invisible, 1 visible)
# Prefer module terminfo, then tput
-zui_list_cursor_visibility() {
    # If $1 = plain, then just output the
    # codes without any state management
    if [[ "$1" != "plain" ]]; then
        # Don't change already set cursor state
        [[ "$cursor_state[$1]" = "$2" ]] && return
        cursor_state[$1]="$2"
    fi

    if [[ -n "${terminfo[cvvis]}" && -n ${terminfo[cnorm]} ]]; then
        [[ "$2" = "1" ]] && { echo -En $terminfo[cvvis]; echo -En $terminfo[cnorm]; }
        [[ "$2" = "0" ]] && echo -n $terminfo[civis]
    elif type tput 2>/dev/null 1>&2; then
        [[ "$2" = "1" ]] && { tput cvvis; tput cnorm; }
        [[ "$2" = "0" ]] && tput civis
    fi 
}

# Conditional, fully robust page-to-show computation
-zui_list_compute_exact_page_if_needed() {
    # Fallback: in case of any problems compute exact page
    if [[ "$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN" -lt "1" ||
        "$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN" -gt "$last_element" ]]
    then
        ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN=$(( ((ZUILIST_CURRENT_IDX-1)/page_height)*page_height+1 ))
    fi
}

# Compute first to show index - page is
# scrolled to center to show given index
-zui_list_compute_first_to_show_idx_center() {
    (( ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN=ZUILIST_CURRENT_IDX-page_height/2 ))
    -zui_list_compute_exact_page_if_needed
}

# current_difference - how many to subtract from current
# element index, last_element_difference - how many to
# subtract from element total count. These values allow
# to provide navigation information when non-selectables
# (non-real elements) are present.
-zui_list_compute_user_vars_difference() {
    # No non-selectables -> no job to do
    if [[ "${(t)ZUILIST_NONSELECTABLE_ELEMENTS}" != *array* ]]
    then
        last_element_difference=0
        current_difference=0
    else
        last_element_difference=${#ZUILIST_NONSELECTABLE_ELEMENTS}
        current_difference=0
        local idx
        for idx in "${(n)ZUILIST_NONSELECTABLE_ELEMENTS[@]}"; do
            [[ "$idx" -le "$ZUILIST_CURRENT_IDX" ]] && current_difference+=1 || break
        done
    fi
}

# List was processed, check if variables aren't off range
-zui_list_verify_vars() {
    [[ "$ZUILIST_CURRENT_IDX" -gt "$last_element" ]] && ZUILIST_CURRENT_IDX="$last_element"
    [[ "$ZUILIST_CURRENT_IDX" -eq 0 && "$last_element" -ne 0 ]] && ZUILIST_CURRENT_IDX=1

    # Verify that element is just visible, if not then compute exact page
    if [[ "$ZUILIST_CURRENT_IDX" -lt "$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN" ||
        "$ZUILIST_CURRENT_IDX" -gt "$(( ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + page_height + 1 ))" ]]
    then
        (( ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN = ((ZUILIST_CURRENT_IDX-1)/page_height) * page_height + 1 ))
    fi
}

# Compute the variables which are shown to the user
-zui_list_setup_user_vars() {
    if [[ "$1" = "1" ]]; then
        # Basic values when there are no non-selectables
        ZUILIST_USER_CURRENT_IDX="$ZUILIST_CURRENT_IDX"
        ZUILIST_USER_LAST_ELEMENT="$last_element"
    else
        -zui_list_compute_user_vars_difference
        ZUILIST_USER_CURRENT_IDX=$(( ZUILIST_CURRENT_IDX - current_difference ))
        ZUILIST_USER_LAST_ELEMENT=$(( last_element - last_element_difference ))
    fi
}

# Functionality inherited from n-list: ability to colorify
# selected keywords (via ZUILIST_COLORING_PATTERN). Here
# it uses color mark (default: \6) instead of direct usage
# of ANSI color codes. \6 is cyan by default (ZUI_CYAN).
#
-zui_list_colorify_disp_list() {
    local col=$'\6' reset=$'\31'
    [[ -n "$ZUILIST_COLORING_COLOR" ]] && col="$ZUILIST_COLORING_COLOR"
    [[ -n "$ZUILIST_COLORING_END_COLOR" ]] && reset="$ZUILIST_COLORING_END_COLOR"

    if [[ "$ZUILIST_COLORING_MATCH_MULTIPLE" -eq 1 ]]; then
        disp_list=( "${(@)disp_list//(#mi)$~ZUILIST_COLORING_PATTERN/$col${MATCH}$reset}" )
    else
        disp_list=( "${(@)disp_list/(#mi)$~ZUILIST_COLORING_PATTERN/$col${MATCH}$reset}" )
    fi
}

# Changes color marks (\3, \4, \5, \6, \7) into ANSI color
# codes (default: green, yellow, magenta, cyan, red).
# Operates on disp_list array.
-zui_list_translate_color_marks_in_disp_list() {
    disp_list=( "${disp_list[@]//(#b)$'\3'([^$'\31']#)$'\31'/$GREEN$match[1]$RESET}" )
    disp_list=( "${disp_list[@]//(#b)$'\4'([^$'\31']#)$'\31'/$YELLOW$match[1]$RESET}" )
    disp_list=( "${disp_list[@]//(#b)$'\5'([^$'\31']#)$'\31'/$MAGENTA$match[1]$RESET}" )
    disp_list=( "${disp_list[@]//(#b)$'\6'([^$'\31']#)$'\31'/$CYAN$match[1]$RESET}" )
    disp_list=( "${disp_list[@]//(#b)$'\7'([^$'\31']#)$'\31'/$RED$match[1]$RESET}" )
}

# Changes color marks (\3, \4, \5, \6, \7) into ANSI color
# codes (default: green, yellow, magenta, cyan, red).
#
# $1 - buffer to operate on
# $REPLY - modified buffer
-zui_list_translate_color_marks() {
    local buf="$1"
    buf=( "${buf//(#b)$'\3'([^$'\31']#)$'\31'/$GREEN$match[1]$RESET}" )
    buf=( "${buf//(#b)$'\4'([^$'\31']#)$'\31'/$YELLOW$match[1]$RESET}" )
    buf=( "${buf//(#b)$'\5'([^$'\31']#)$'\31'/$MAGENTA$match[1]$RESET}" )
    buf=( "${buf//(#b)$'\6'([^$'\31']#)$'\31'/$CYAN$match[1]$RESET}" )
    buf=( "${buf//(#b)$'\7'([^$'\31']#)$'\31'/$RED$match[1]$RESET}" )
    REPLY="$buf"
}

# Replaces existing color marks to given color mark,
# or adds (wrapps with) given color mark. Used to
# highlight text.
#
# $1 - buffer to operate on
# $2 - target color mark
# $REPLY - modified buffer
-zui_list_replace_color_marks_with() {
    local buf="$1" target_mark="$2"
    buf=${buf//$'\3'/$target_mark}
    buf=${buf//$'\4'/$target_mark}
    buf=${buf//$'\5'/$target_mark}
    buf=${buf//$'\6'/$target_mark}

    # No existing replaced marks – then just add the mark
    if [[ "${buf/$target_mark/}" = "$buf" ]]; then
        buf="${target_mark}${buf}"$'\31'
    fi

    REPLY="$buf"
}

-zui_list_mark_current_segment_in_current_element() {
        # Check if current element is in ZUILIST_NONSELECTABLE_ELEMENTS
        # If yes, don't mark current segment. Highlight anyway when
        # searching.
        [[ -z "$ZUILIST_SEARCH_BUFFER" && "${ZUILIST_NONSELECTABLE_ELEMENTS[(r)$ZUILIST_CURRENT_IDX]}" = "$ZUILIST_CURRENT_IDX" ]] && return

        # There will be no colorifying for current element
        integer current_page_idx=$(( ZUILIST_CURRENT_IDX - ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + 1 ))
        local element="$list[ZUILIST_CURRENT_IDX]"
        local output=""

        [[ "$ZUILIST_CURRENT_SEGMENT" -lt 1 ]] && ZUILIST_CURRENT_SEGMENT=1
        [[ "$ZUILIST_CURRENT_SEGMENT" -gt "$nseg" ]] && ZUILIST_CURRENT_SEGMENT="$nseg"
        integer active_segment="$ZUILIST_CURRENT_SEGMENT"

        # Lets find interesting segment and mark it with \7...\31
        zui-process-buffer "$element"
        integer size="${#ZUI_PB_WORDS}" i
        local buf=""
        for (( i=1; i<=size; i++ )); do
            if [[ "$i" -eq "$active_segment" ]]; then
                ZUI_PB_WORDS[i]=${ZUI_PB_WORDS[i]//$'\n'/\\n}
                -zui_list_replace_color_marks_with "${ZUI_PB_WORDS[i]}" $'\7'
                ZUI_PB_WORDS[i]="$REPLY"
            fi
            buf+="$ZUI_PB_SPACES[i]$ZUI_PB_WORDS[i]"
        done
        buf+="$ZUI_PB_SPACES[i]"

        -zui_list_translate_color_marks "$buf"
        disp_list2[current_page_idx]="$REPLY"
}

#
# Main code
#

if [[ "$#" -lt 1 ]]; then
    echo "Usage: zui-list element_1 ..."
    return 1
fi

typeset -g REPLY
REPLY="-1"
typeset -ga reply
reply=()

local wname_main="$1"
integer main_height="$2"
integer main_width="$3"
local wname_status="$4"
integer status_height="$5"
integer status_width="$6"
integer page_height=main_height-2
integer page_width=main_width-2
local header="$7"
local mark_header="$8"

shift 8

typeset -a list disp_list disp_list2
integer last_element=$#
local action
local final_key
integer selection
integer last_element_difference=0
integer current_difference=0
local prev_search_buffer=""
integer prev_uniq_mode=0
integer prev_start_idx=-1
local MBEGIN MEND MATCH
local -a mbegin mend match
local -a segments
integer nseg
typeset -A "cursor_state"
cursor_state=( "main" 1 "status" 1 )

# Escape codes for colors
local RESET=$'\e[0m' RED=$'\e[0;31m' GREEN=$'\e[0;32m'
local YELLOW=$'\e[1;33m' MAGENTA=$'\e[0;35m' CYAN=$'\e[0;36m'

#
# Load configuration – per application if ZUI[app] is set
#

local colorpair border bold background backuptheme
zstyle -s ":plugin:zui" "colorpair" colorpair || colorpair="white/black"
zstyle -t ":plugin:zui" "border" && border="1" || border="0"
zstyle -t ":plugin:zui" "bold" && bold="+bold" || bold="-bold"

[[ -n "${ZUI[app]}" ]] && {
    local zstyle_path=":plugin:zui:app:${ZUI[app]}" colorpair2
    zstyle -s $zstyle_path "colorpair" colorpair2 && colorpair="$colorpair2"
    # -t - false when unset or false, -T - false when false
    zstyle -t $zstyle_path "border" && border="1" || zstyle -T $zstyle_path "border" || border="0"
    zstyle -t $zstyle_path "bold" && bold="+bold" || zstyle -t $zstyle_path "bold" || bold="-bold"
    unset zstyle_path colorpair2
}

background="${colorpair#*/}"
backuptheme="$colorpair/$bold"

# Set background
zcurses bg "$wname_main" "$colorpair"
zcurses bg "$wname_status" "$colorpair"

# Ability to remember the list between calls
if [[ -z "$ZUILIST_REMEMBER_STATE" || "$ZUILIST_REMEMBER_STATE" = 0 || "$ZUILIST_REMEMBER_STATE" = 2 ]]; then
    ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN=1
    ZUILIST_CURRENT_IDX=1
    ZUILIST_IS_SEARCH_MODE=0
    ZUILIST_SEARCH_BUFFER=""
    ZUILIST_TEXT_OFFSET=0
    ZUILIST_IS_UNIQ_MODE=0
    ZUILIST_CURRENT_SEGMENT=1 # This variable is responsible for horizontal indexing
    ZUILIST_ACTIVE_SEGMENTS=()

    # Zero - because it isn't known, unless we
    # confirm that first element is selectable
    ZUILIST_USER_CURRENT_IDX=0
    [[ ${ZUILIST_NONSELECTABLE_ELEMENTS[(r)1]} != 1 ]] && ZUILIST_USER_CURRENT_IDX=1
    ZUILIST_USER_LAST_ELEMENT=$(( last_element - $#ZUILIST_NONSELECTABLE_ELEMENTS ))

    # 2 is init once, then remember
    [[ "$ZUILIST_REMEMBER_STATE" -eq 2 ]] && ZUILIST_REMEMBER_STATE=1
else
    # Recompute ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN in case
    # it was manually altered outside the list. Together with
    # this verify variables.
    -zui_list_verify_vars
fi

if [[ "$ZUILIST_START_IN_SEARCH_MODE" -eq 1 ]]; then
    ZUILIST_START_IN_SEARCH_MODE=0
    ZUILIST_IS_SEARCH_MODE=1
fi

if [[ -n "$ZUILIST_SET_SEARCH_TO" ]]; then
    ZUILIST_SEARCH_BUFFER="$ZUILIST_SET_SEARCH_TO"
    ZUILIST_SET_SEARCH_TO=""
fi

if [[ "$ZUILIST_START_IN_UNIQ_MODE" -eq 1 ]]; then
    ZUILIST_START_IN_UNIQ_MODE=0
    ZUILIST_IS_UNIQ_MODE=1
fi

#
# Listening for input
#

local key keypad

# Clear input buffer
zcurses timeout main 0
zcurses input main key keypad
zcurses timeout main -1
key=""
keypad=""

# Initial list. $@ later still serves as verbatim input.
# This loop makes script faster on some Zsh's (e.g. 5.0.8)
repeat 1; do
    list=( "$@" )
done

last_element="$#list"

while (( 1 )); do
    # Do searching?
    if [[ -n "$ZUILIST_SEARCH_BUFFER" ]]; then
        # Compute new list?
        if [[ "$ZUILIST_SEARCH_BUFFER" != "$prev_search_buffer" || "$ZUILIST_IS_UNIQ_MODE" -ne "$prev_uniq_mode" || "$ZUILIST_REGENERATE_DISP_LIST" = "1" ]]
        then
            prev_search_buffer="$ZUILIST_SEARCH_BUFFER"
            prev_uniq_mode="$ZUILIST_IS_UNIQ_MODE"
            # regenerating list -> regenerating disp_list
            prev_start_idx=-1

            # Take all elements, including duplicates and non-selectables
            typeset +U list
            repeat 1; do
                list=( "$@" )
            done

            # Remove non-selectable elements
            [[ "$#ZUILIST_NONSELECTABLE_ELEMENTS" -gt 0 ]] && for i in "${(nO)ZUILIST_NONSELECTABLE_ELEMENTS[@]}"; do
                list[$i]=()
            done

            # Remove duplicates
            [[ "$ZUILIST_IS_UNIQ_MODE" -eq 1 ]] && typeset -U list

            last_element="$#list"

            # Next do the filtering
            local search_buffer="${ZUILIST_SEARCH_BUFFER%% ##}"
            search_buffer="${search_buffer## ##}"
            search_buffer="${search_buffer//(#m)[][*?|#~^()><\\]/\\$MATCH}"
            local search_pattern=""
            local colsearch_pattern=""
            if [[ -n "$search_buffer" ]]; then
                # The base bit of this pattern is ((#s)[^$'\1']#THEWORD*|*$'\2'[^$'\1']#THEWORD*) - the word
                # occuring not inside hyper link
                # Pattern will be ((#s)[^$'\1']#FOO*|*$'\2'[^$'\1']#FOO*)~^((#s)[^$'\1']#BAR*|*$'\2'[^$'\1']#BAR*...)
                # ~^ means: "not those that have not this"
                search_pattern=${search_buffer//(#b)([^ ]##)/((#s)[^$'\1']#$match[1]*|*$'\2'[^$'\1']#$match[1]*)~^}
                search_pattern="${search_pattern// ##/}"
                search_pattern="${search_pattern%\~\^}"
                # Pattern will be (foo|bar)
                colsearch_pattern="${search_buffer// ##/|}"

                # The repeat will make the matching work on a fresh heap arena
                repeat 1; do
                    list=( "${(@M)list:#(#i)$~search_pattern}" )
                done

                last_element="$#list"
            fi

            # Called after processing list
            -zui_list_verify_vars
        fi

        -zui_list_setup_user_vars 1
        segments=( "${(z)list[ZUILIST_CURRENT_IDX]}" )
        nseg="$#segments"

        integer end_idx=$(( ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + page_height - 1 ))
        [[ "$end_idx" -gt "$last_element" ]] && end_idx=last_element

        if [[ "$prev_start_idx" -ne "$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN" ]]; then
            prev_start_idx="$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN"
            disp_list=( "${(@)list[ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN, end_idx]}" )

            if [[ -n "$colsearch_pattern" ]]; then
                local col=$'\5' reset=$'\31'
                # The repeat will make the matching work on a fresh heap
                repeat 1; do
                    disp_list=( ${(@)disp_list//(#mi)($~colsearch_pattern)/$col${MATCH}$reset} )
                    # [Mark][Text][Red-Mark][Text2][Close]... -> [Mark][Text][Close][Red-Mark][Text2][Close][Mark]
                    # I.e. provide [Close] before [Red-Mark] and [Mark] after red's [Close]
                    while (( 1 )); do
                        match=()
                        disp_list=( ${(@)disp_list//(#b)([$'\3'$'\4'$'\5'$'\6'])([^$'\31']#)$'\5'([^$'\31']#)$'\31'/$match[1]$match[2]$'\31'$'\5'$match[3]$'\31'$match[1]} )
                        [[ -z "${match[1]}" ]] && break
                    done
                done
            fi
            # We translate color marks into color codes. list still contains marks,
            # and -zui_list_mark_current_segment_in_current_element will be able
            # to restore current element into marks, to switch colors of active
            # segment
            -zui_list_translate_color_marks_in_disp_list
        fi

        # We need second disp_list to be able to disable colorifying for particular elements
        disp_list2=( "${(@)disp_list}" )

        [[ "$#disp_list2" -gt 0 ]] && -zui_list_mark_current_segment_in_current_element

        # Remove hyperlinks before displaying
        disp_list2=( "${disp_list2[@]//$'\1'[^$'\1']#$'\1'[^$'\1']#$'\1'[^$'\1']#$'\1'[^$'\1']#$'\1'[^$'\1']#$'\2'/}" )

        # Output colored list
        zui-list-draw "$(( ZUILIST_CURRENT_IDX - ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + 1 ))" \
            "$page_height" "$page_width" 1 2 "$ZUILIST_TEXT_OFFSET" "$wname_main" \
            "$disp_list2[@]"
    else
        # There is no search, but there was in previous loop
        # OR
        # Uniq mode was entered or left out
        # -> compute new list
        if [[ -n "$prev_search_buffer" || "$ZUILIST_IS_UNIQ_MODE" -ne "$prev_uniq_mode" || "$ZUILIST_REGENERATE_DISP_LIST" = "1" ]]
        then
            prev_search_buffer=""
            prev_uniq_mode="$ZUILIST_IS_UNIQ_MODE"
            # regenerating list -> regenerating disp_list
            prev_start_idx=-1

            # Take all elements, including duplicates and non-selectables
            typeset +U list
            repeat 1; do
                list=( "$@" )
            done

            # Remove non-selectable elements only when in uniq mode
            [[ "$ZUILIST_IS_UNIQ_MODE" -eq 1 ]] && [[ "$#ZUILIST_NONSELECTABLE_ELEMENTS" -gt 0 ]] &&
            for i in "${(nO)ZUILIST_NONSELECTABLE_ELEMENTS[@]}"; do
                list[$i]=()
            done

            # Remove duplicates when in uniq mode
            [[ "$ZUILIST_IS_UNIQ_MODE" -eq 1 ]] && typeset -U list

            last_element="$#list"
            # Called after processing list
            -zui_list_verify_vars
        fi

        # If the argument is 1, then: don't bother with non-selectables
        -zui_list_setup_user_vars "$ZUILIST_IS_UNIQ_MODE"
        segments=( "${(z)list[ZUILIST_CURRENT_IDX]}" )
        nseg="$#segments"

        integer end_idx=$(( ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + page_height - 1 ))
        [[ "$end_idx" -gt "$last_element" ]] && end_idx=last_element

        if [[ "$prev_start_idx" -ne "$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN" ]]; then
            prev_start_idx="$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN"
            disp_list=( "${(@)list[ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN, end_idx]}" )

            # We translate color marks into color codes. list still contains marks,
            # and -zui_list_mark_current_segment_in_current_element will be able
            # to restore current element into marks, to switch colors of active
            # segment
            -zui_list_translate_color_marks_in_disp_list

            [[ -n "$ZUILIST_COLORING_PATTERN" ]] && -zui_list_colorify_disp_list
        fi

        # We need second disp_list to be able to disable colorifying for particular elements
        # (this is rather unused currently)
        disp_list2=( "${(@)disp_list}" )

        [[ "$#disp_list2" -gt 0 ]] && -zui_list_mark_current_segment_in_current_element

        # Remove hyperlinks before displaying
        disp_list2=( "${disp_list2[@]//$'\1'[^$'\1']#$'\1'[^$'\1']#$'\1'[^$'\1']#$'\1'[^$'\1']#$'\1'[^$'\1']#$'\2'/}" )

        # Output the list
        zui-list-draw "$(( ZUILIST_CURRENT_IDX - ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + 1 ))" \
            "$page_height" "$page_width" 1 2 "$ZUILIST_TEXT_OFFSET" "$wname_main" \
            "$disp_list2[@]"
    fi

    # The check for "white/black" means: mark header
    # only when default color isn't special
    [[ "$mark_header" = "1" && "$colorpair" = "white/black" ]] && zcurses attr "$wname_main" "$bold" "magenta/$background"
    [[ "$border" = "1" ]] && zcurses border "$wname_main"
    zcurses move "$wname_main" 0 2
    zcurses string "$wname_main" "$header"
    [[ "$mark_header" = "1" && "$colorpair" = "white/black" ]] && zcurses attr "$wname_main" "$bold" "$colorpair"
    -zui_list_cursor_visibility "main" "0"
    zcurses refresh "$wname_main"

    # Status window is optional (1/2)
    [[ -n "$wname_status" ]] && {
        reply=( )
        if -zui_stdlib_decode_hyperlink "${segments[$ZUILIST_CURRENT_SEGMENT]}"; then
            (( ${+functions[-zui-standard-status-callback]} )) && -zui-standard-status-callback "${reply[@]}"
        fi

        local status_msg_strlen _uniq="" _text="" _grep="" _gen=""
        [[ "$ZUILIST_IS_UNIQ_MODE" = "1" ]] && _uniq="[-UNIQ-]"
        [[ -n "$ZUILIST_GREP_STRING" ]] && _grep="[$ZUILIST_GREP_STRING]"
        [[ -n "${ZUI[GENERATION_TIME]}" ]] && _gen="GENERATED IN ${ZUI[GENERATION_TIME]}s"
        ZUI[GENERATION_TIME]=""

        if [[ "$ZUILIST_IS_SEARCH_MODE" = "1" ]]; then
            -zui_list_status_msg "$_uniq" "Filtering with: ${ZUILIST_SEARCH_BUFFER// /+}"
        elif [[ ${ZUILIST_NONSELECTABLE_ELEMENTS[(r)$ZUILIST_CURRENT_IDX]} != $ZUILIST_CURRENT_IDX || -n "$ZUILIST_SEARCH_BUFFER" || "$ZUILIST_IS_UNIQ_MODE" -eq 1 ]]; then
            _text="Current #$ZUILIST_USER_CURRENT_IDX (of #$ZUILIST_USER_LAST_ELEMENT entries)"
            -zui_list_status_msg "$_uniq" "$_text" "$_grep" "$_gen" "${reply[@]}"
        else
            # "[UNIQ]", "Text", "[Grep string]", "Generation time", "$reply[@]" from callback
            -zui_list_status_msg "" "" "" "$_gen"
        fi

        [[ "$border" = "1" ]] && zcurses border "$wname_status"
        # status_msg_strlen is being set in -zui_list_status_msg()
        zcurses move "$wname_status" 1 $(( status_msg_strlen + 2 ))
        [[ "$ZUILIST_IS_SEARCH_MODE" -ne 1 ]] && -zui_list_cursor_visibility "status" "0" || -zui_list_cursor_visibility "status" "1"
        zcurses refresh "$wname_status" 
    }

    # Draw only?
    [[ "$ZUILIST_DRAW_ONLY" = "1" ]] && return

    # Wait for input
    zcurses input main key keypad

    # Get the special (i.e. "keypad") key or regular key
    if [[ -n "$key" ]]; then
        final_key="$key"
    elif [[ -n "$keypad" ]]; then
        final_key="$keypad"
    else
        [[ -n "$wname_status" ]] && {
            -zui_list_status_msg "" "Inproper input detected"
            zcurses refresh "$wname_status"
            sleep 1
        }
    fi

    integer track_cur_idx="$ZUILIST_CURRENT_IDX"
    zui-list-input "$ZUILIST_CURRENT_IDX" "$ZUILIST_CURRENT_SEGMENT" "$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN" \
                    "$page_height" "$page_width" "$last_element" "$nseg" "$ZUILIST_TEXT_OFFSET" \
                    "$final_key" "$ZUILIST_IS_SEARCH_MODE" "$ZUILIST_SEARCH_BUFFER" \
                    "$ZUILIST_IS_UNIQ_MODE" "$ZUILIST_DISABLE_SEARCH" "list"

    selection="$reply[1]"
    action="$reply[2]"
    ZUILIST_CURRENT_IDX="$reply[3]"
    ZUILIST_CURRENT_SEGMENT="$reply[4]"
    ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN="$reply[5]"
    ZUILIST_TEXT_OFFSET="$reply[6]"
    ZUILIST_IS_SEARCH_MODE="$reply[7]"
    ZUILIST_SEARCH_BUFFER="$reply[8]"
    ZUILIST_IS_UNIQ_MODE="$reply[9]"

    #
    # Remember selected segment at each line?
    # (functionality)
    #

    if [[ "$ZUILIST_TRACK_SEGMENTS" = "1" ]]; then
        # Remember segment change (element change and
        # segment change cannot occur at the same time)
        ZUILIST_ACTIVE_SEGMENTS[$track_cur_idx]="$ZUILIST_CURRENT_SEGMENT"

        if [[ "$track_cur_idx" != "$ZUILIST_CURRENT_IDX" ]]; then
            # Restore segment or set to 1
            if (( ${+ZUILIST_ACTIVE_SEGMENTS[$ZUILIST_CURRENT_IDX]} )); then
                ZUILIST_CURRENT_SEGMENT="${ZUILIST_ACTIVE_SEGMENTS[$ZUILIST_CURRENT_IDX]}"
            else
                ZUILIST_CURRENT_SEGMENT=1
            fi
        fi
    fi

    #
    # Main input action examination
    #

    if [[ "$action" = "SELECT" ]]; then
        REPLY="$selection"
        reply=( "$list[@]" )
        break
    elif [[ "$action" = F[1-4] ]]; then
        REPLY="$action"
        reply=( "$list[@]" )
        break
    elif [[ "$action" = "BR_MOVE_LEFT" || "$action" = "BR_MOVE_RIGHT" ]]; then
        REPLY="$action"
        reply=( "$list[@]" )
        break
    elif [[ "$action" = "QUIT" ]]; then
        REPLY=-1
        reply=( "$list[@]" )
        break
    elif [[ "$action" = "REDRAW" ]]; then
        zcurses clear "$wname_main" redraw
        # Status window is optional (2/2)
        [[ -n "$wname_status" ]] && zcurses clear "$wname_status" redraw
    elif [[ "$action" = "HYPERLINK" ]]; then
        -zui_stdlib_get_segment "${list[ZUILIST_CURRENT_IDX]}" "$ZUILIST_CURRENT_SEGMENT"
        -zui_stdlib_decode_hyperlink $REPLY
        local id="${reply[1]}"
        integer call_hook=0
        if [[ "$id" = zuianchor* ]]; then
            ZUILIST_CURRENT_IDX="${ZUI[$id]-${reply[2]}}"
            ZUILIST_CURRENT_SEGMENT=1
            -zui_list_compute_first_to_show_idx_center
            id="zuiiaction${id#zuianchor}"
            call_hook=1
        elif [[ "$id" = zuicheckbox* ]]; then
            call_hook=1
        elif [[ "$id" = zuiiaction* ]]; then
            call_hook=1
        fi

        # Is there hook to launch?
        if [[ $call_hook -gt 0 && -n "${ZUI[$id]}" ]]; then
            reply[1]="${${${${${reply[1]#zuiiaction}#zuiaction}#zuicheckbox}#zuieanchor}#zuianchor}"
            # Call the handler with all hyper-link
            # data or eval code, not using the data
            [[ "${ZUI[$id]}" = *(=|\(\()* ]] && eval "${ZUI[$id]}" || "${ZUI[$id]}" "${reply[@]}"
        fi
    fi

    # Now check if there are any update-on-the-fly packages submitted
    local -a update
    -zui_stdlib_decode_list_update "${ZUI[fly_update]}" update
    ZUI[fly_update]=""

    if [[ ${update[2]} -ge 1 ]]; then
        integer update_first=$update[1]
        integer update_count=$update[2]
        shift 2 update
        integer update_size=${#update}

        # Update $@ array of this function - it
        # is "zui-list", main UI function, and
        # $@ holds original input data. So it
        # can be said that here a restart of
        # zui-list is simulated
        set "${(@)@[1,update_first-1]}" "${update[@]}" "${(@)@[update_first+update_count,-1]}"

        typeset -g ZUILIST_REGENERATE_DISP_LIST
        ZUILIST_REGENERATE_DISP_LIST="1"

        # How many elements push down (up if negative)
        # indices that are after the modified section
        integer size_diff=$(( update_size - update_count )) mysize
        local index el var_name

        # Remove indices that lay inside the block being overwritten
        # NONSELECTABLES
        mysize="${#ZUILIST_NONSELECTABLE_ELEMENTS[@]}"
        for (( index = 1; index <= mysize; index ++ )); do
            el="${ZUILIST_NONSELECTABLE_ELEMENTS[index]}"
            if [[ "$el" -ge "$update_first" && "$el" -le "$(( update_first + update_count - 1 ))" ]]
            then
                ZUILIST_NONSELECTABLE_ELEMENTS[index]=()
            fi
        done

        # Push down (up) elements that are after the growed (shrinked) section
        # NONSELECTABLES
        mysize="${#ZUILIST_NONSELECTABLE_ELEMENTS[@]}"
        for (( index = 1; index <= mysize; index ++ )); do
            el="${ZUILIST_NONSELECTABLE_ELEMENTS[index]}"
            # No need to check if it lays inside the range
            # as ones that did have been removed above
            if [[ "$el" -gt "$(( update_first + update_count - 1 ))" ]]; then
                (( ZUILIST_NONSELECTABLE_ELEMENTS[index] += size_diff ))
            fi
        done

        # Remove indices that lay inside the block being overwritten
        # HOPS
        mysize="${#ZUILIST_HOP_INDICES[@]}"
        for (( index = 1; index <= mysize; index ++ )); do
            el="${ZUILIST_HOP_INDICES[index]}"
            if [[ "$el" -ge "$update_first" && "$el" -le "$(( update_first + update_count - 1 ))" ]]
            then
                ZUILIST_HOP_INDICES[index]=()
            fi
        done

        # Push down (up) elements that are after the growed (shrinked) section
        # HOPS
        mysize="${#ZUILIST_HOP_INDICES[@]}"
        for (( index = 1; index <= mysize; index ++ )); do
            el="${ZUILIST_HOP_INDICES[index]}"
            # No need to check if it lays inside the range
            # as ones that did have been removed above
            if [[ "$el" -gt "$(( update_first + update_count - 1 ))" ]]; then
                (( ZUILIST_HOP_INDICES[index] += size_diff ))
            fi
        done

        # Push down (up) *_global_index parameters
        for (( index = 1; index <= 1000; index ++ )); do
            var_name="module${index}_global_index"
            [[ "${(P)+var_name}" = "0" ]] && break

            el="${(P)var_name}"
            if [[ -n "$el" && "$el" -gt "$(( update_first + update_count - 1 ))" ]]; then
                : ${(P)var_name::=$(( el + size_diff ))}
            fi
        done

        # Now add new hops and nonselectables
        # first translating to global indices
        local -a nonselectables hops
        -zui_stdlib_decode_nonselectables "${ZUI[fly_nonselectables]}" nonselectables
        -zui_stdlib_decode_hops "${ZUI[fly_hops]}" hops
        ZUI[fly_nonselectables]=""
        ZUI[fly_hops]=""

        nonselectables=( "${nonselectables[@]//(#b)([[:digit:]]##)/$(( ${match[1]} + update_first - 1 ))}" )
        hops=( "${hops[@]//(#b)([[:digit:]]##)/$(( ${match[1]} + update_first - 1 ))}" )

        ZUILIST_NONSELECTABLE_ELEMENTS+=( "${nonselectables[@]}" )
        ZUILIST_HOP_INDICES+=( "${hops[@]}" )

        # Update existing anchors: global ones get
        # pushed down (up), local ones get globalized.
        local -a lanchors
        -zui_stdlib_decode_lanchors "${ZUI[fly_lanchors]}" lanchors
        for el in ${ZUI[(I)zuianchor*]} ${ZUI[(I)zuieanchor*]}; do
            if [[ "${lanchors[(r)${el#zuianchor}]}" = ${el#zuianchor} ]]; then
                (( ZUI[$el] += update_first - 1 ))
            elif [[ "${lanchors[(r)${el#zuieanchor}]}" = ${el#zuieanchor} ]]; then
                (( ZUI[$el] += update_first - 1 ))
            else
                index=${ZUI[$el]:-0}
                # Anchors after the replaced block
                if [[ "$index" -gt $(( update_first + update_count - 1 )) ]]; then
                    ZUI[$el]=$(( index + size_diff ))
                fi
            fi
        done

        # Cleanup
        unset update update_size nonselectables
        unset update_first update_count hops
        unset index mysize el var_name
    elif (( ${+ZUILIST_REPLY_CHECKBOX_NUM} )); then
        local new_line="${@[ZUILIST_REPLY_CHECKBOX_NUM]}"
        [[ "$ZUILIST_REPLY_CHECKBOX_OP" = "set" ]] && new_line="${new_line/\[_\]/[x]}" || new_line="${new_line/\[x\]/[_]}"
        set "${(@)@[1,ZUILIST_REPLY_CHECKBOX_NUM-1]}" "$new_line" "${(@)@[ZUILIST_REPLY_CHECKBOX_NUM+1,-1]}"
        typeset -g ZUILIST_REGENERATE_DISP_LIST="1"
        unset ZUILIST_REPLY_CHECKBOX_NUM ZUILIST_REPLY_CHECKBOX_OP
    fi
done

# vim: set filetype=zsh:
