# $1 - main window name
# $2, $3 - width and height of the window
# $4 - optional status window name
# $5, $6 - width and height of the window
#
# $ZUILIST_NONSELECTABLE_ELEMENTS - array of indexes (1-based) that cannot be selected
# $ZUILIST_HOP_INDICES - array of indexes (1-based) jumpable with [, ]
#
# $REPLY is the output variable - contains index (1-based) or -1 when no selection
# $reply (array) is the second part of the output - use the index (REPLY) to get selected element
#
# This function outputs a list of elements that can be navigated with keyboard.
# Besides vertical navigation, it does horizontal navigation over elements of line.
# Uses curses library.

emulate -LR zsh

setopt typesetsilent extendedglob noshortloops
[[ "${ZUI[PROMPT_SUBST]}" = "1" ]] && setopt promptsubst

zmodload zsh/curses
zmodload zsh/terminfo 2>/dev/null

trap "REPLY=-2; reply=(); return" TERM INT QUIT

[[ "${ZUI[stdlib_sourced]}" != "1" ]] && source "${ZUI_REPO_DIR}/lib/stdlib.lzui"

# Outputs a message in the bottom of the screen
# "[UNIQ]", "Text", "[Grep string]", "Generation time", "$reply[@]" from callback
-zui_list_status_msg() {
    integer indent=2 line="${ZUI[status_border]}"

    zcurses clear "$wname_status"
    zcurses move "$wname_status" $line $indent
    zcurses string "$wname_status" "$1"
    (( status_msg_strlen += ${#1} ))
}

# $1 is window name, $2 is the expected cursor state (0 invisible, 1 visible)
# Prefer module terminfo, then tput
-zui_list_cursor_visibility() {
    # If $1 = plain, then just output the
    # codes without any state management
    if [[ "$1" != "plain" ]]; then
        # Don't change already set cursor state
        [[ "$cursor_state[$1]" = "$2" ]] && return
        cursor_state[$1]="$2"
    fi

    if [[ -n "${terminfo[cvvis]}" && -n ${terminfo[cnorm]} ]]; then
        [[ "$2" = "1" ]] && { echo -En $terminfo[cvvis]; echo -En $terminfo[cnorm]; }
        [[ "$2" = "0" ]] && echo -n $terminfo[civis]
    elif type tput 2>/dev/null 1>&2; then
        [[ "$2" = "1" ]] && { tput cvvis; tput cnorm; }
        [[ "$2" = "0" ]] && tput civis
    fi 
}

# Conditional, fully robust page-to-show computation
-zui_list_compute_exact_page_if_needed() {
    # Fallback: in case of any problems compute exact page
    if [[ "$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN" -lt "1" ||
        "$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN" -gt "$last_element" ]]
    then
        ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN=$(( ((ZUILIST_CURRENT_IDX-1)/page_height)*page_height+1 ))
    fi
}

# Compute first to show index - page is
# scrolled to center to show given index
-zui_list_compute_first_to_show_idx_center() {
    (( ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN=ZUILIST_CURRENT_IDX-page_height/2 ))
    -zui_list_compute_exact_page_if_needed
}

# current_difference - how many to subtract from current
# element index, last_element_difference - how many to
# subtract from element total count. These values allow
# to provide navigation information when non-selectables
# (non-real elements) are present.
-zui_list_compute_user_vars_difference() {
    # No non-selectables -> no job to do
    if [[ "${(t)ZUILIST_NONSELECTABLE_ELEMENTS}" != *array* ]]
    then
        last_element_difference=0
        current_difference=0
    else
        last_element_difference=${#ZUILIST_NONSELECTABLE_ELEMENTS}
        current_difference=0
        local idx
        for idx in "${(n)ZUILIST_NONSELECTABLE_ELEMENTS[@]}"; do
            [[ "$idx" -le "$ZUILIST_CURRENT_IDX" ]] && current_difference+=1 || break
        done
    fi
}

# List was processed, check if variables aren't off range
-zui_list_verify_vars() {
    [[ "$ZUILIST_CURRENT_IDX" -gt "$last_element" ]] && ZUILIST_CURRENT_IDX="$last_element"
    [[ "$ZUILIST_CURRENT_IDX" -eq 0 && "$last_element" -ne 0 ]] && ZUILIST_CURRENT_IDX=1

    # Verify that element is just visible, if not then compute exact page
    if [[ "$ZUILIST_CURRENT_IDX" -lt "$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN" ||
        "$ZUILIST_CURRENT_IDX" -gt "$(( ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + page_height - 1 ))" ]]
    then
        (( ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN = ((ZUILIST_CURRENT_IDX-1)/page_height) * page_height + 1 ))
    fi
}

# Compute the variables which are shown to the user
-zui_list_setup_user_vars() {
    if [[ "$1" = "1" ]]; then
        # Basic values when there are no non-selectables
        ZUILIST_USER_CURRENT_IDX="$ZUILIST_CURRENT_IDX"
        ZUILIST_USER_LAST_ELEMENT="$last_element"
    else
        -zui_list_compute_user_vars_difference
        ZUILIST_USER_CURRENT_IDX=$(( ZUILIST_CURRENT_IDX - current_difference ))
        ZUILIST_USER_LAST_ELEMENT=$(( last_element - last_element_difference ))
    fi
}

# Functionality inherited from n-list: ability to colorify
# selected keywords (via ZUILIST_COLORING_PATTERN). Here
# it uses color mark (default: \6) instead of direct usage
# of ANSI color codes. \6 is cyan by default (ZUI[CYAN]).
#
-zui_list_colorify_disp_list() {
    local col=${ZUI[CYAN]} close=${ZUI[COLOR_END]}
    [[ -n "$ZUILIST_COLORING_COLOR" ]] && col="$ZUILIST_COLORING_COLOR"
    [[ -n "$ZUILIST_COLORING_END_COLOR" ]] && close="$ZUILIST_COLORING_END_COLOR"

    if [[ "$ZUILIST_COLORING_MATCH_MULTIPLE" -eq 1 ]]; then
        disp_list=( "${(@)disp_list//(#mi)$~ZUILIST_COLORING_PATTERN/$col${MATCH}$close}" )
    else
        disp_list=( "${(@)disp_list/(#mi)$~ZUILIST_COLORING_PATTERN/$col${MATCH}$close}" )
    fi
}

# Changes color marks (default: \3, \4, \5, \6, \7) into ANSI
# color codes (default: green, yellow, magenta, cyan, red).
# Operates on disp_list array.
-zui_list_translate_color_marks_in_disp_list() {
    # [all] [fg] [bg]
    disp_list=( "${disp_list[@]//(#b)([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\031'])([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\017']|)([$'\020'-$'\030']|)([^${ZUI[COLOR_END]}]#)${ZUI[COLOR_END]}/${colormap[${match[1]}]}${colormap[${match[2]}]}${colormap[${match[3]}]}$match[4]$RESET}" )
}

# Changes color marks (default: \3, \4, \5, \6, \7) into ANSI
# color codes (default: green, yellow, magenta, cyan, red).
#
# $1 - buffer to operate on
# $REPLY - modified buffer
-zui_list_translate_color_marks() {
    local buf="$1"
    # [all] [fg] [bg]
    buf="${buf//(#b)([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\031'])([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\017']|)([$'\020'-$'\030']|)([^${ZUI[COLOR_END]}]#)${ZUI[COLOR_END]}/${colormap[${match[1]}]}${colormap[${match[2]}]}${colormap[${match[3]}]}$match[4]$RESET}"

    # Mark
    buf="${buf//(#b)${ZUI[MARK]}([^${ZUI[MARK_E]}]#)${ZUI[MARK_E]}/$MARK_CODES$match[1]$MARK_END_CODES}"

    REPLY="$buf"
}

# Replaces existing color marks to given color mark,
# or adds (wrapps with) given color mark. Used to
# highlight text.
#
# $1 - buffer to operate on
# $2 - target color mark
# $REPLY - modified buffer
-zui_list_replace_color_marks_with() {
    local buf="$1" target_mark="$2"
    # [all] [fg] [bg]
    buf=${buf//[$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\031']([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\017']|)([$'\020'-$'\030']|)/$target_mark}

    # No existing replaced marks – then just add the mark
    if [[ "${buf/$target_mark/}" = "$buf" ]]; then
        buf="${target_mark}${buf}${ZUI[COLOR_END]}"
    fi

    REPLY="$buf"
}

-zui_list_mark_current_segment_in_current_element() {
        # Check if current element is in ZUILIST_NONSELECTABLE_ELEMENTS
        # If yes, don't mark current segment. Highlight anyway when
        # searching.
        [[ -z "$ZUILIST_SEARCH_BUFFER" && "$ZUILIST_IS_UNIQ_MODE" != "1" && -n "${ZUILIST_NONSELECTABLE_ELEMENTS[(r)$ZUILIST_CURRENT_IDX]}" ]] && return

        # There will be no colorifying for current element
        integer current_page_idx=$(( ZUILIST_CURRENT_IDX - ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + 1 ))
        local element="${list[ZUILIST_CURRENT_IDX]}"
        local output=""

        [[ "$ZUILIST_CURRENT_SEGMENT" -lt 1 ]] && ZUILIST_CURRENT_SEGMENT=1
        [[ "$ZUILIST_CURRENT_SEGMENT" -gt "$nseg" ]] && ZUILIST_CURRENT_SEGMENT="$nseg"
        integer active_segment="$ZUILIST_CURRENT_SEGMENT"

        # Lets find interesting segment and mark it with \7...\31
        zui-process-buffer "$element"
        integer size="${#ZUI_PB_WORDS}" i
        local buf=""
        for (( i=1; i<=size; i++ )); do
            if [[ "$i" -eq "$active_segment" ]]; then
                ZUI_PB_WORDS[i]=${ZUI_PB_WORDS[i]//$'\n'/\\n}
                -zui_list_replace_color_marks_with "${ZUI_PB_WORDS[i]}" "${ZUI[MARK]}"
                ZUI_PB_WORDS[i]="$REPLY"
            fi
            buf+="$ZUI_PB_SPACES[i]$ZUI_PB_WORDS[i]"
        done
        buf+="$ZUI_PB_SPACES[i]"

        -zui_list_translate_color_marks "$buf"
        disp_list2[current_page_idx]="$REPLY"
}

#
# Main code
#

if [[ "$#" -lt 1 ]]; then
    echo "Usage: zui-list element_1 ..."
    return 1
fi

typeset -g REPLY
REPLY="-1"
typeset -ga reply
reply=()

local wname_main="$1"
integer main_height="$2"
integer main_width="$3"
local wname_status="$4"
integer status_height="$5"
integer status_width="$6"
integer page_height=main_height-2
integer page_width=main_width-2
local header="$7"

shift 7

typeset -a list disp_list disp_list2
integer last_element=$#
local action
local final_key
integer selection
integer last_element_difference=0
integer current_difference=0
local prev_search_buffer=""
integer prev_uniq_mode=0
integer prev_start_idx=-1
local MBEGIN MEND MATCH
local -a mbegin mend match
local -a segments
integer nseg
typeset -A "cursor_state"
cursor_state=( "main" 1 "status" 1 )

# Escape codes for colors
local RESET=$'\e[0m' BLACK=$'\e[30m' RED=$'\e[31m' GREEN=$'\e[32m' YELLOW=$'\e[33m'
local BLUE=$'\e[34m' MAGENTA=$'\e[35m' CYAN=$'\e[36m' WHITE=$'\e[37m' DEFAULT=$'\e[39m'

# Background
local BG_BLACK=$'\e[40m' BG_RED=$'\e[41m' BG_GREEN=$'\e[42m' BG_YELLOW=$'\e[43m'
local BG_BLUE=$'\e[44m' BG_MAGENTA=$'\e[45m' BG_CYAN=$'\e[46m' BG_WHITE=$'\e[47m' BG_DEFAULT=$'\e[49m'

# Bold
local BOLD=$'\e[1m'

local -A colormap
colormap=(
    ""                ""

    $ZUI[BLACK]       $BLACK
    $ZUI[RED]         $RED
    $ZUI[GREEN]       $GREEN
    $ZUI[YELLOW]      $YELLOW
    $ZUI[BLUE]        $BLUE
    $ZUI[MAGENTA]     $MAGENTA
    $ZUI[CYAN]        $CYAN
    $ZUI[WHITE]       $WHITE
    $ZUI[DEFAULT]     $DEFAULT

    $ZUI[BG_BLACK]    $BG_BLACK
    $ZUI[BG_RED]      $BG_RED
    $ZUI[BG_GREEN]    $BG_GREEN
    $ZUI[BG_YELLOW]   $BG_YELLOW
    $ZUI[BG_BLUE]     $BG_BLUE
    $ZUI[BG_MAGENTA]  $BG_MAGENTA
    $ZUI[BG_CYAN]     $BG_CYAN
    $ZUI[BG_WHITE]    $BG_WHITE
    $ZUI[BG_DEFAULT]  $BG_DEFAULT

    $ZUI[BOLD]        $BOLD
)

#
# Load configuration – per application if ZUI[app] is set
#

local actmark altmark background foreground backuptheme
local stbackground stforeground stbackuptheme
-zui_stdlib_load_config s:colorpair "white/black" 2 'ZUI[colorpair]'
-zui_stdlib_load_config b:border 0 2 'ZUI[border]'
-zui_stdlib_load_config s:border_cp "yellow/black" 2 'ZUI[border_cp]'
-zui_stdlib_load_config b:bold 0 2 'ZUI[bold]'

-zui_stdlib_load_config s:status_colorpair "white/black" 2 'ZUI[status_colorpair]'
-zui_stdlib_load_config b:status_border 0 2 'ZUI[status_border]'
-zui_stdlib_load_config s:status_border_cp "green/black" 2 'ZUI[status_border_cp]'
-zui_stdlib_load_config b:status_bold 0 2 'ZUI[status_bold]'

-zui_stdlib_load_config s:mark "red reverse lineund" 2 actmark
-zui_stdlib_load_config s:altmark "red reverse" 2 altmark
-zui_stdlib_load_config b:text_mode 1 2 'ZUI[text_mode]'
-zui_stdlib_load_config b:text_select 1 2 'ZUI[text_select]'
-zui_stdlib_load_config b:status_pointer 1 2 'ZUI[status_pointer]'
-zui_stdlib_load_config s:log_append "above" 2 'ZUI[log_append]'
-zui_stdlib_load_config b:log_index 1 2 'ZUI[log_index]'
-zui_stdlib_load_config s:log_size "32" 2 'ZUI[log_size]'
-zui_stdlib_load_config s:log_time_format "[%H:%M] " 2 'ZUI[log_time_format]'
-zui_stdlib_load_config s:log_colors "white cyan yellow green cyan red magenta yellow blue" 2 'ZUI[log_colors]'
local -a log_colors
log_colors=( "${=ZUI[log_colors]}" )

# Process configuration
background="${ZUI[colorpair]#*/}"
foreground="${ZUI[colorpair]%/*}"
backuptheme="${ZUI[colorpair]}/${ZUI[bold]}"
stbackground="${ZUI[status_colorpair]#*/}"
stforeground="${ZUI[status_colorpair]%/*}"
stbackuptheme="${ZUI[status_colorpair]}/${ZUI[status_bold]}"
local MARK_CODES MARK_END_CODES active_text
() {
    # Check if terminal supports underline
    # Linux has ncv 18, screen* has ncv 3 - underline won't work properly
    (( ${+terminfo} )) && (( ${terminfo[ncv]:-0} & 2 )) && actmark="$altmark"
    # FreeBSD uses TERM=xterm for newcons but doesn't actually support underline
    [[ "$TERM" = "xterm" && -z "$DISPLAY" && "${(L)OSTYPE}" = *bsd* ]] && actmark="$altmark"

    local color="${actmark%%[[:space:]]*}"
    local color2="${${actmark#*[[:space:]]}%%[[:space:]]*}"
    local bold="${actmark/*bold*/bold}"
    local reverse="${actmark/*(reverse|inverse)*/reverse}"
    local blink="${actmark/*blink*/blink}"
    local underline="${actmark/*underline*/underline}"
    local linerev="${actmark/*linerev*/linerev}"
    local lineund="${actmark/*lineund*/lineund}"
    local -A colormap
    colormap=( reset 0 black 30 red 31 green 32 yellow 33 blue 34 magenta 35 cyan 36 white 37 default 39
                       BLACK 30 RED 41 GREEN 42 YELLOW 43 BLUE 44 MAGENTA 45 CYAN 46 WHITE 47 DEFAULT 49 )
    local -aU opening closing
    [[ -n "${colormap[$color]}" ]] && { opening+=( ${colormap[$color]} ); closing+=( 0 ); }
    [[ -n "${colormap[$color2]}" ]] && { opening+=( ${colormap[$color2]} ); closing+=( 0 ); }
    [[ $linerev = linerev ]] && { active_text="reverse"; reverse=""; }
    [[ $lineund = lineund ]] && { active_text="underline"; underline=""; }
    [[ $bold == bold ]] && { opening+=( 1 ); closing+=( 21 ); }
    [[ $reverse == reverse ]] && { opening+=( 7 ); closing+=( 27 ); }
    [[ $blink == blink ]] && { opening+=( 5 ); closing+=( 25 ); }
    [[ $underline == underline ]] && { opening+=( 4 ); closing+=( 24 ); }

    local a opcodes clcodes
    for a in "${opening[@]}"; do
        opcodes+=$'\e'"[${a}m"
    done
    for a in "${closing[@]}"; do
        clcodes+=$'\e'"[${a}m"
    done

    MARK_CODES="$opcodes"
    MARK_END_CODES="$clcodes"
}

# Set background
zcurses bg "$wname_main" "${ZUI[colorpair]}"
zcurses bg "$wname_status" "${ZUI[status_colorpair]}"

# Ability to remember the list between calls
if [[ -z "$ZUILIST_REMEMBER_STATE" || "$ZUILIST_REMEMBER_STATE" = 0 || "$ZUILIST_REMEMBER_STATE" = 2 ]]; then
    ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN=1
    ZUILIST_CURRENT_IDX=1
    ZUILIST_IS_SEARCH_MODE=0
    ZUILIST_SEARCH_BUFFER=""
    ZUILIST_TEXT_OFFSET=0
    ZUILIST_IS_UNIQ_MODE=0
    ZUILIST_CURRENT_SEGMENT=1 # This variable is responsible for horizontal indexing
    ZUILIST_ACTIVE_SEGMENTS=()
    typeset -ga +U ZUILIST_NONSELECTABLE_ELEMENTS
    typeset -ga +U ZUILIST_HOP_INDICES

    # Zero - because it isn't known, unless we
    # confirm that first element is selectable
    ZUILIST_USER_CURRENT_IDX=0
    [[ -z "${ZUILIST_NONSELECTABLE_ELEMENTS[(r)1]}" ]] && ZUILIST_USER_CURRENT_IDX=1
    ZUILIST_USER_LAST_ELEMENT=$(( last_element - $#ZUILIST_NONSELECTABLE_ELEMENTS ))

    # 2 is init once, then remember
    [[ "$ZUILIST_REMEMBER_STATE" -eq 2 ]] && ZUILIST_REMEMBER_STATE=1
else
    # Recompute ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN in case
    # it was manually altered outside the list. Together with
    # this verify variables.
    -zui_list_verify_vars

    # This retains previous parameters, adds unique flag
    typeset -ga +U ZUILIST_NONSELECTABLE_ELEMENTS
    typeset -ga +U ZUILIST_HOP_INDICES
fi

if [[ "$ZUILIST_START_IN_SEARCH_MODE" -eq 1 ]]; then
    ZUILIST_START_IN_SEARCH_MODE=0
    ZUILIST_IS_SEARCH_MODE=1
fi

if [[ -n "$ZUILIST_SET_SEARCH_TO" ]]; then
    ZUILIST_SEARCH_BUFFER="$ZUILIST_SET_SEARCH_TO"
    ZUILIST_SET_SEARCH_TO=""
fi

if [[ "$ZUILIST_START_IN_UNIQ_MODE" -eq 1 ]]; then
    ZUILIST_START_IN_UNIQ_MODE=0
    ZUILIST_IS_UNIQ_MODE=1
fi

#
# Listening for input
#

local key keypad

# Clear input buffer
zcurses timeout main 0
zcurses input main key keypad
zcurses timeout main -1
key=""
keypad=""

# Initial list. $@ later still serves as verbatim input.
# This loop makes script faster on some Zsh's (e.g. 5.0.8)
repeat 1; do
    list=( "$@" )
done

last_element="$#list"

while (( 1 )); do
    # Do searching?
    if [[ -n "$ZUILIST_SEARCH_BUFFER" ]]; then
        # Compute new list?
        if [[ "$ZUILIST_SEARCH_BUFFER" != "$prev_search_buffer" || "$ZUILIST_IS_UNIQ_MODE" -ne "$prev_uniq_mode" || "$ZUILIST_REGENERATE_DISP_LIST" = "1" ]]
        then
            prev_search_buffer="$ZUILIST_SEARCH_BUFFER"
            prev_uniq_mode="$ZUILIST_IS_UNIQ_MODE"
            # regenerating list -> regenerating disp_list
            prev_start_idx=-1

            # Take all elements, including duplicates and non-selectables
            typeset +U list
            repeat 1; do
                list=( "$@" )
            done

            # Remove non-selectable elements
            [[ "$#ZUILIST_NONSELECTABLE_ELEMENTS" -gt 0 ]] && for i in "${(nO)ZUILIST_NONSELECTABLE_ELEMENTS[@]}"; do
                list[$i]=()
            done

            # Remove duplicates
            [[ "$ZUILIST_IS_UNIQ_MODE" -eq 1 ]] && typeset -U list

            last_element="$#list"

            # Next do the filtering
            local search_buffer="${ZUILIST_SEARCH_BUFFER%% ##}"
            search_buffer="${search_buffer## ##}"
            search_buffer="${search_buffer//(#m)[][*?|#~^()><\\]/\\$MATCH}"
            local search_pattern=""
            local colsearch_pattern=""
            if [[ -n "$search_buffer" ]]; then
                # The base bit of this pattern is ((#s)[^$'\01']#THEWORD*|*$'\02'[^$'\01']#THEWORD*) - the word
                # occuring not inside hyper link
                # Pattern will be ((#s)[^$'\01']#FOO*|*$'\02'[^$'\01']#FOO*)~^((#s)[^$'\01']#BAR*|*$'\02'[^$'\01']#BAR*...)
                # ~^ means: "not those that have not this"
                search_pattern=${search_buffer//(#b)([^ ]##)/((#s)[^$'\01']#$match[1]*|*$'\02'[^$'\01']#$match[1]*)~^}
                search_pattern="${search_pattern// ##/}"
                search_pattern="${search_pattern%\~\^}"
                # Pattern will be (foo|bar)
                colsearch_pattern="${search_buffer// ##/|}"

                # The repeat will make the matching work on a fresh heap arena
                repeat 1; do
                    list=( "${(@M)list:#(#i)$~search_pattern}" )
                done

                last_element="$#list"
            fi

            # Called after processing list
            -zui_list_verify_vars
        fi

        -zui_list_setup_user_vars 1
        segments=( "${(z)list[ZUILIST_CURRENT_IDX]}" )
        nseg="$#segments"

        integer end_idx=$(( ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + page_height - 1 ))
        [[ "$end_idx" -gt "$last_element" ]] && end_idx=last_element

        if [[ "$prev_start_idx" -ne "$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN" ]]; then
            prev_start_idx="$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN"
            disp_list=( "${(@)list[ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN, end_idx]}" )

            if [[ -n "$colsearch_pattern" ]]; then
                local col="${ZUI[BG_MAGENTA]}" close="${ZUI[COLOR_END]}"
                # The repeat will make the matching work on a fresh heap arena
                repeat 1; do
                    disp_list=( ${(@)disp_list//(#mi)($~colsearch_pattern)/$col${MATCH}$close} )
                    # [Mark][Text][$col-Mark][Text2][Close]... -> [Mark][Text][Close][$col-Mark][Text2][Close][Mark]
                    # I.e. provide [Close] before [$col-Mark] and [Mark] after $col's [Close]
                    # Here is the ancient common *_E obstacle - we can easily use only single [Close] in the substitution
                    while (( 1 )); do
                        # [all] [fg] [bg], matches more combinations but solves and is fast
                        mbegin=()
                        disp_list=( ${(@)disp_list//(#b)([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\031']([$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\017']|)([$'\020'-$'\030']|))([^$close]#)$col([^$close]#)$close/$match[1]$match[4]$close$col$match[5]$close$match[1]} )
                        [[ -z "${mbegin[1]}" ]] && break
                    done
                done
            fi
            # We translate color marks into color codes. list still contains marks,
            # and -zui_list_mark_current_segment_in_current_element will be able
            # to restore current element into marks, to switch colors of active
            # segment
            -zui_list_translate_color_marks_in_disp_list
        fi

        # We need second disp_list to be able to disable colorifying for particular elements
        disp_list2=( "${(@)disp_list}" )

        [[ "$#disp_list2" -gt 0 ]] && -zui_list_mark_current_segment_in_current_element

        # Remove hyperlinks before displaying
        disp_list2=( "${disp_list2[@]//$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\02'/}" )

        # Output colored list
        zui-list-draw "$(( ZUILIST_CURRENT_IDX - ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + 1 ))" \
            "$page_height" "$page_width" 1 2 "$ZUILIST_TEXT_OFFSET" "$wname_main" \
            "$disp_list2[@]"
    else
        # There is no search, but there was in previous loop
        # OR
        # Uniq mode was entered or left out
        # -> compute new list
        if [[ -n "$prev_search_buffer" || "$ZUILIST_IS_UNIQ_MODE" -ne "$prev_uniq_mode" || "$ZUILIST_REGENERATE_DISP_LIST" = "1" ]]
        then
            prev_search_buffer=""
            prev_uniq_mode="$ZUILIST_IS_UNIQ_MODE"
            # regenerating list -> regenerating disp_list
            prev_start_idx=-1

            # Take all elements, including duplicates and non-selectables
            typeset +U list
            repeat 1; do
                list=( "$@" )
            done

            # Remove non-selectable elements only when in uniq mode
            [[ "$ZUILIST_IS_UNIQ_MODE" -eq 1 ]] && [[ "$#ZUILIST_NONSELECTABLE_ELEMENTS" -gt 0 ]] &&
            for i in "${(nO)ZUILIST_NONSELECTABLE_ELEMENTS[@]}"; do
                list[$i]=()
            done

            # Remove duplicates when in uniq mode
            [[ "$ZUILIST_IS_UNIQ_MODE" -eq 1 ]] && typeset -U list

            last_element="$#list"
            # Called after processing list
            -zui_list_verify_vars
        fi

        # If the argument is 1, then: don't bother with non-selectables
        -zui_list_setup_user_vars "$ZUILIST_IS_UNIQ_MODE"
        segments=( "${(z)list[ZUILIST_CURRENT_IDX]}" )
        nseg="$#segments"

        integer end_idx=$(( ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + page_height - 1 ))
        [[ "$end_idx" -gt "$last_element" ]] && end_idx=last_element

        if [[ "$prev_start_idx" -ne "$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN" ]]; then
            prev_start_idx="$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN"
            disp_list=( "${(@)list[ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN, end_idx]}" )

            # We translate color marks into color codes. list still contains marks,
            # and -zui_list_mark_current_segment_in_current_element will be able
            # to restore current element into marks, to switch colors of active
            # segment
            -zui_list_translate_color_marks_in_disp_list

            [[ -n "$ZUILIST_COLORING_PATTERN" ]] && -zui_list_colorify_disp_list
        fi

        # We need second disp_list to be able to disable colorifying for particular elements
        # (this is rather unused currently)
        disp_list2=( "${(@)disp_list}" )

        [[ "$#disp_list2" -gt 0 ]] && -zui_list_mark_current_segment_in_current_element

        # Remove hyperlinks before displaying
        disp_list2=( "${disp_list2[@]//$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\02'/}" )

        # Output the list
        zui-list-draw "$(( ZUILIST_CURRENT_IDX - ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + 1 ))" \
            "$page_height" "$page_width" 1 2 "$ZUILIST_TEXT_OFFSET" "$wname_main" \
            "$disp_list2[@]"
    fi

    [[ "${ZUI[bold]}" = "1" ]] && local wrk_bold="+bold" || local wrk_bold="-bold"

    # The check for "white/black" means: mark header
    # only when default color isn't special
    zcurses attr "$wname_main" "$wrk_bold" "${ZUI[border_cp]}"

    [[ "${ZUI[border]}" = "1" ]] && zcurses border "$wname_main"
    zcurses move "$wname_main" 0 2
    zcurses string "$wname_main" "$header"

    zcurses attr "$wname_main" "$wrk_bold" "${ZUI[colorpair]}"

    -zui_list_cursor_visibility "main" "0"
    zcurses refresh "$wname_main"

    # Status window is optional (1/2)
    [[ -n "$wname_status" ]] && {
        [[ "${ZUI[status_bold]}" = "1" ]] && local wrk_stbold="+bold" || local wrk_stbold="-bold"

        zcurses attr "$wname_status" "$wrk_stbold" "${ZUI[status_colorpair]}"

        reply=( )
        local selectable=1 tpe=-1 status_msg_strlen=0
        [[ -n "${ZUILIST_NONSELECTABLE_ELEMENTS[(r)$ZUILIST_CURRENT_IDX]}" ]] && selectable=0
        (( $ZUILIST_IS_UNIQ_MODE + ${${ZUILIST_SEARCH_BUFFER:+1}:-0} )) && selectable=1
        if (( selectable == 0 )) || ! -zui_stdlib_decode_hyperlink "${segments[ZUILIST_CURRENT_SEGMENT]}"; then
            reply=( "" "$selectable" "$ZUILIST_IS_UNIQ_MODE" "${${ZUILIST_SEARCH_BUFFER:+1}:-0}" "${segments[ZUILIST_CURRENT_SEGMENT]}" )
        fi
        (( ${+functions[-zui-standard-status-callback]} )) && {
            -zui-standard-status-callback "${reply[@]}"
            tpe=$?
        }
        ZUI[pressed_now]=""

        (( tpe >= 0 )) && -zui_stdlib_add_message "$tpe" "${EPOCHSECONDS:-0}" "${reply[@]}"

        if [[ "$ZUILIST_IS_SEARCH_MODE" = "0" ]]; then
            -zui-log "$wname_status" "$status_height" "$status_width" "${ZUI[status_border]}" "${ZUI[status_colorpair]}" \
                    "$ZUILIST_GREP_STRING" "$ZUILIST_IS_UNIQ_MODE" "$ZUILIST_IS_SEARCH_MODE" \
                    "${ZUI[GENERATION_TIME]}" "$selectable" "${${ZUILIST_SEARCH_BUFFER:+1}:-0}" \
                    "$ZUILIST_CURRENT_IDX" "$last_element"

            ZUI[GENERATION_TIME]=""
        else
            -zui_list_status_msg "Filtering with: ${ZUILIST_SEARCH_BUFFER// /+}"
        fi

        [[ "${ZUI[status_border]}" = "1" ]] && {
            zcurses attr "$wname_status" "$wrk_stbold" "${ZUI[status_border_cp]}"
            zcurses border "$wname_status"
            zcurses attr "$wname_status" "$wrk_stbold" "${ZUI[status_colorpair]}"
        }

        # status_msg_strlen is being set in -zui_list_status_msg()
        zcurses move "$wname_status" "${ZUI[status_border]}" $(( status_msg_strlen + 2 ))
        [[ "$ZUILIST_IS_SEARCH_MODE" -ne 1 ]] && -zui_list_cursor_visibility "status" "0" || -zui_list_cursor_visibility "status" "1"
        zcurses refresh "$wname_status" 
    }

    # Draw only?
    [[ "$ZUILIST_DRAW_ONLY" = "1" ]] && return

    # Wait for input
    zcurses input main key keypad

    # Get the special (i.e. "keypad") key or regular key
    if [[ -n "$key" ]]; then
        final_key="$key"
    elif [[ -n "$keypad" ]]; then
        final_key="$keypad"
    else
        [[ -n "$wname_status" ]] && {
            -zui_list_status_msg "" "Inproper input detected"
            zcurses refresh "$wname_status"
            sleep 1
        }
    fi

    integer track_cur_idx="$ZUILIST_CURRENT_IDX"
    zui-list-input "$ZUILIST_CURRENT_IDX" "$ZUILIST_CURRENT_SEGMENT" "$ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN" \
                    "$page_height" "$page_width" "$last_element" "$nseg" "$ZUILIST_TEXT_OFFSET" \
                    "$final_key" "$ZUILIST_IS_SEARCH_MODE" "$ZUILIST_SEARCH_BUFFER" \
                    "$ZUILIST_IS_UNIQ_MODE" "$ZUILIST_DISABLE_SEARCH" "list"

    selection="$reply[1]"
    action="$reply[2]"
    ZUILIST_CURRENT_IDX="$reply[3]"
    ZUILIST_CURRENT_SEGMENT="$reply[4]"
    ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN="$reply[5]"
    ZUILIST_TEXT_OFFSET="$reply[6]"
    ZUILIST_IS_SEARCH_MODE="$reply[7]"
    ZUILIST_SEARCH_BUFFER="$reply[8]"
    ZUILIST_IS_UNIQ_MODE="$reply[9]"

    #
    # Remember selected segment at each line?
    # (functionality)
    #

    if [[ "$ZUILIST_TRACK_SEGMENTS" = "1" ]]; then
        # Remember segment change (element change and
        # segment change cannot occur at the same time)
        ZUILIST_ACTIVE_SEGMENTS[$track_cur_idx]="$ZUILIST_CURRENT_SEGMENT"

        if [[ "$track_cur_idx" != "$ZUILIST_CURRENT_IDX" ]]; then
            # Restore segment or set to 1
            if (( ${+ZUILIST_ACTIVE_SEGMENTS[$ZUILIST_CURRENT_IDX]} )); then
                ZUILIST_CURRENT_SEGMENT="${ZUILIST_ACTIVE_SEGMENTS[$ZUILIST_CURRENT_IDX]}"
            else
                ZUILIST_CURRENT_SEGMENT=1
            fi
        fi
    fi

    #
    # Main input action examination
    #

    # If a jump is set up by anchor,
    # these parameter(s) will be set
    local jump_id="" jump_data=""

    if [[ "$action" = "SELECT" ]]; then
        REPLY="$selection"
        reply=( "$list[@]" )
        break
    elif [[ "$action" = F[1-4] ]]; then
        REPLY="$action"
        reply=( "$list[@]" )
        break
    elif [[ "$action" = "BR_MOVE_LEFT" || "$action" = "BR_MOVE_RIGHT" ]]; then
        REPLY="$action"
        reply=( "$list[@]" )
        break
    elif [[ "$action" = "QUIT" ]]; then
        REPLY=-1
        reply=( "$list[@]" )
        break
    elif [[ "$action" = "REDRAW" ]]; then
        zcurses clear "$wname_main" redraw
        # Status window is optional (2/2)
        [[ -n "$wname_status" ]] && zcurses clear "$wname_status" redraw
    elif [[ "$action" = "HYPERLINK" ]]; then
        -zui_stdlib_get_segment "${list[ZUILIST_CURRENT_IDX]}" "$ZUILIST_CURRENT_SEGMENT"
        -zui_stdlib_decode_hyperlink $REPLY
        local id="${reply[1]}"
        ZUI[pressed_now]="$id"
        integer call_hook=0
        if [[ "$id" = zuianchor* ]]; then
            jump_id="$id"
            jump_data="${reply[2]}"
            id="zuiiaction${id#zuianchor}"
            call_hook=1
        elif [[ "$id" = zuicheckbox* ]]; then
            call_hook=1
        elif [[ "$id" = zuiiaction* ]]; then
            call_hook=1
        fi

        # Is there hook to launch?
        if [[ $call_hook -gt 0 && -n "${ZUI[$id]}" ]]; then
            reply[1]="${${${${${reply[1]#zuiiaction}#zuiaction}#zuicheckbox}#zuieanchor}#zuianchor}"
            # Call the handler with all hyper-link
            # data or eval code, not using the data
            [[ "${ZUI[$id]}" = *(=|\(\()* ]] && eval "${ZUI[$id]}" || "${ZUI[$id]}" "${reply[@]}"
        fi
    fi

    # Now check if there are any update-on-the-fly packages submitted
    local -a update
    -zui_stdlib_decode_list_update "${ZUI[fly_update]}" update
    ZUI[fly_update]=""

    if [[ ${update[3]} -ge 1 ]]; then
        # If not empty, we're updating whole
        # module and want this be treated as
        # module regeneration
        local module=$update[1]
        integer update_first=$update[2]
        integer update_count=$update[3]
        shift 3 update
        integer update_size=${#update}

        # Update $@ array of this function - it
        # is "zui-list", main UI function, and
        # $@ holds original input data. So it
        # can be said that here a restart of
        # zui-list is simulated
        set -- "${(@)@[1,update_first-1]}" "${update[@]}" "${(@)@[update_first+update_count,-1]}"

        typeset -g ZUILIST_REGENERATE_DISP_LIST
        ZUILIST_REGENERATE_DISP_LIST="1"

        # How many elements push down (up if negative)
        # indices that are after the modified section
        integer size_diff=$(( update_size - update_count )) mysize
        local index el var_name

        if [[ -n "$module" ]]; then
            local -a prev_nonselectables
            var_name="prev_module${module}_nonselectables"
            prev_nonselectables=( "${(PA@)var_name}" )
            # Remove previous nonselectables, ^ is negation, ( ) is filled with "|"-joined previous elements
            ZUILIST_NONSELECTABLE_ELEMENTS=( ${(@M)ZUILIST_NONSELECTABLE_ELEMENTS:#(#b)^(${~${(j:|:)prev_nonselectables}})} )
        fi

        # Push down (up) elements that are after the growed (shrinked) section
        # NONSELECTABLES
        mysize="${#ZUILIST_NONSELECTABLE_ELEMENTS[@]}"
        for (( index = 1; index <= mysize; index ++ )); do
            el="${ZUILIST_NONSELECTABLE_ELEMENTS[index]}"
            # No need to check if it lays inside the range
            # as ones that did have been removed above
            if [[ "$el" -gt "$(( update_first + update_count - 1 ))" ]]; then
                (( ZUILIST_NONSELECTABLE_ELEMENTS[index] += size_diff ))
            fi
        done

        if [[ -n "$module" ]]; then
            local -a prev_hops
            var_name="prev_module${module}_hops"
            prev_hops=( "${(PA@)var_name}" )
            ZUILIST_HOP_INDICES=( ${(@M)ZUILIST_HOP_INDICES:#(#b)^(${~${(j:|:)prev_hops}})} )
        fi

        # Push down (up) elements that are after the growed (shrinked) section
        # HOPS
        mysize="${#ZUILIST_HOP_INDICES[@]}"
        for (( index = 1; index <= mysize; index ++ )); do
            el="${ZUILIST_HOP_INDICES[index]}"
            # No need to check if it lays inside the range
            # as ones that did have been removed above
            if [[ "$el" -gt "$(( update_first + update_count - 1 ))" ]]; then
                (( ZUILIST_HOP_INDICES[index] += size_diff ))
            fi
        done

        # Push down (up) *_global_index parameters
        for (( index = 1; index <= 1000; index ++ )); do
            var_name="module${index}_global_index"
            [[ "${(P)+var_name}" = "0" ]] && break

            el="${(P)var_name}"
            if [[ -n "$el" && "$el" -gt "$(( update_first + update_count - 1 ))" ]]; then
                : ${(P)var_name::=$(( el + size_diff ))}
            fi
        done

        # Now add new hops and nonselectables
        # first translating to global indices
        local -a nonselectables hops
        -zui_stdlib_decode_nonselectables "${ZUI[fly_nonselectables]}" nonselectables
        -zui_stdlib_decode_hops "${ZUI[fly_hops]}" hops
        ZUI[fly_nonselectables]=""
        ZUI[fly_hops]=""

        nonselectables=( "${nonselectables[@]//(#b)([[:digit:]]##)/$(( ${match[1]} + update_first - 1 ))}" )
        hops=( "${hops[@]//(#b)([[:digit:]]##)/$(( ${match[1]} + update_first - 1 ))}" )

        ZUILIST_NONSELECTABLE_ELEMENTS+=( "${nonselectables[@]}" )
        ZUILIST_HOP_INDICES+=( "${hops[@]}" )

        if [[ -n "$module" ]]; then
            # Treat as module update - fill prev_*
            # parameters and also *_global_index
            var_name="prev_module${module}_nonselectables"
            : "${(PA)var_name::=${nonselectables[@]}}";
            var_name="prev_module${module}_hops"
            : "${(PA)var_name::=${hops[@]}}";
            var_name="prev_module${module}_size"
            : "${(P)var_name::=$update_size}";
            var_name="module${module}_global_index"
            : "${(P)var_name::=$update_first}";
        fi

        # Update existing anchors: global ones get
        # pushed down (up), local ones (not yet
        # processed, new) are only globalized
        local -a lanchors
        -zui_stdlib_decode_lanchors "${ZUI[fly_lanchors]}" lanchors
        for el in ${ZUI[(I)zuianchor*]} ${ZUI[(I)zuieanchor*]}; do
            if [[ "${lanchors[(r)${el#zuianchor}]}" = ${el#zuianchor} ]]; then
                ZUI[$el]=$(( ${ZUI[$el]%[-+]*} + update_first - 1 ))"${ZUI[$el]##[0-9]##}"
            elif [[ "${lanchors[(r)${el#zuieanchor}]}" = ${el#zuieanchor} ]]; then
                ZUI[$el]=$(( ${ZUI[$el]%[-+]*} + update_first - 1 ))"${ZUI[$el]##[0-9]##}"
            else
                # The $el anchor is after the replaced block?
                # In this detection only "a" in "a+b" matters
                if [[ "${ZUI[$el]%[-+]*}" -gt $(( update_first + update_count - 1 )) ]]; then
                    ZUI[$el]=$(( ${ZUI[$el]%[-+]*} + size_diff ))"${ZUI[$el]##[0-9]##}"
                fi
            fi
        done

        # On-the-fly module regeneration, not only
        # list update - this means lanchors have
        # been submitted to module${idx}_lanchors
        # parameter. They are now fully processed.
        if [[ -n "$module" ]]; then
            var_name="module${module}_lanchors"
            : ${(PA)var_name::=}
        fi

        # Cleanup
        unset update update_size nonselectables
        unset update_first update_count hops
        unset index mysize el var_name
    elif (( ${+ZUILIST_REPLY_CHECKBOX_NUM} )); then
        local new_line="${@[ZUILIST_REPLY_CHECKBOX_NUM]}"
        [[ "$ZUILIST_REPLY_CHECKBOX_OP" = "set" ]] && new_line="${new_line/\[_\]/[x]}" || new_line="${new_line/\[x\]/[_]}"
        set "${(@)@[1,ZUILIST_REPLY_CHECKBOX_NUM-1]}" "$new_line" "${(@)@[ZUILIST_REPLY_CHECKBOX_NUM+1,-1]}"
        typeset -g ZUILIST_REGENERATE_DISP_LIST="1"
        unset ZUILIST_REPLY_CHECKBOX_NUM ZUILIST_REPLY_CHECKBOX_OP
    fi

    # Anchor to jump? Can be after on-the-fly
    # regeneration submitted by hook call above
    if [[ -n "$jump_id" ]]; then
        ZUILIST_CURRENT_IDX=$(( ${ZUI[$jump_id]:-$jump_data} ))
        (( ZUILIST_CURRENT_IDX < 1 )) && ZUILIST_CURRENT_IDX=1
        (( ZUILIST_CURRENT_IDX > last_element )) && ZUILIST_CURRENT_IDX="$last_element"
        ZUILIST_CURRENT_SEGMENT=1
        -zui_list_compute_first_to_show_idx_center
    fi
done

# vim: set filetype=zsh:
