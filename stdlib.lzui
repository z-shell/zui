#
# Library file (*.lzui)
#
# Standard functions
#

ZUI[stdlib_sourced]="1"

# Available colors to embed in generated text
#
# Excluded codes, recognized by curses, are: 010,
# 011, 012, 015, 033. Tabulation is handled by
# this library (conversion to spaces).
#
# Foreground range: $'\03'-$'\07' $'\013'-$'\014' $'\016'-$'\017'
# Background range: $'\020'-$'\030'. With BOLD it is ...-$'\031'
# Formatting codes range: $'\03'-$'\07' $'\013'-$'\014' $'\016'-$'\031'
#
# \01 and \02 are used by buttons, \032, \02 by text fields

# If one would want to use the lib without plugin...
typeset -gA ZUI
typeset -ga ZUI_MESSAGES

# Ends colors and bold
ZUI[COLOR_END]=$'\037'      # octal value, decimal 31 - Unit separator

# Foreground, excluded are 010, 011, 012, 015
ZUI[BLACK]=$'\03'           # End of text
ZUI[RED]=$'\04'             # End of transmission
ZUI[GREEN]=$'\05'           # Enquiry
ZUI[YELLOW]=$'\06'          # Acknowledge
ZUI[BLUE]=$'\07'            # Bell
ZUI[MAGENTA]=$'\013'        # Vertical tab
ZUI[CYAN]=$'\014'           # Form feed
ZUI[WHITE]=$'\016'          # Shift out
ZUI[DEFAULT]=$'\017'        # Shift in

# Background, no exclusions
ZUI[BG_BLACK]=$'\020'       # Data line escape
ZUI[BG_RED]=$'\021'         # Device control 1
ZUI[BG_GREEN]=$'\022'       # Device control 2
ZUI[BG_YELLOW]=$'\023'      # Device control 3
ZUI[BG_BLUE]=$'\024'        # Device control 4
ZUI[BG_MAGENTA]=$'\025'     # Negative acknowledge
ZUI[BG_CYAN]=$'\026'        # Synchronous idle
ZUI[BG_WHITE]=$'\027'       # End transmission block
ZUI[BG_DEFAULT]=$'\030'     # Cancel

# Bold
ZUI[BOLD]=$'\031'           # End of medium

# Buttons' separator
ZUI[HYP_SEP]=$'\01'

# Text fields's separator
ZUI[FLD_SEP]=$'\032'

# List boxes' separator
ZUI[LST_SEP]=$'\034'

# Hyperlink end
ZUI[HYP_END]=$'\02'

# Special code used to mark active button
ZUI[MARK]=$'\035'           # octal value, decimal 29 - Group separator
ZUI[MARK2]=$'\036'          # octal value, decimal 30 - Record separator
ZUI[MARK_E]=$ZUI[COLOR_END]

# Initializes ZUI application.
# To be called before any emulate
# -L or setopt localoptions command.
function -zui_stdlib_init() {
    [[ -o interactivecomments ]] && ZUI[INTERACTIVE_COMMENTS]="1" || ZUI[INTERACTIVE_COMMENTS]="0"
    [[ -o promptsubst ]] && ZUI[PROMPT_SUBST]="1" || ZUI[PROMPT_SUBST]="0"
}

# Appends hyperlink into output array. It's the standard
# action button, shown without surrounding "[" and "]".
#
# $1 - action ID
# $2 - data1, e.g. timestamp
# $3 - data2, e.g. command
# $4 - data3, e.g. active path
# $5 - data4, e.g. file path, file name, URL, other data
# $6 - text
# $7 - optional handler function name, can be empty text
# $8 - optional output variable name (defualt: 'reply')
#
# Output array is extended by hyperlink's text (one new element)
#
function -zui_stdlib_button() {
    local __id="${(q)1}" __data1="${(q)2}" __data2="${(q)3}" __data3="${(q)4}" __data4="${(q)5}" __text="$6" __handler="$7"
    local __var_name="${8:-reply}"

    local pfx=""
    [[ -n "$__handler" ]] && {
        [[ $__handler = *internal* ]] && pfx="zuiiaction" || pfx="zuiaction"
        ZUI[$pfx$__id]="$__handler"
    }

    # Quote only text, not codes
    __text="${__text//(#b)([^$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\031'$'0\037']##)/${(q)match[1]}}"

    local -a __output
    __output=( "${(P@)__var_name}" $'\01'"$pfx$__id"$'\01'"$__data1"$'\01'"$__data2"$'\01'"$__data3"$'\01'"$__data4"$'\02'"${__text}"$'\02' )

    unset pfx __id __data1 __data2 __data3 __data4 __text __handler
    : ${(PA)__var_name::=${__output[@]}}
}

# Appends button hyperlink into "reply" output array
#
# Arguments are the same as in -zui_stdlib_button
#
function -zui_stdlib_rc_button() {
    local __id="${(q)1}" __data1="${(q)2}" __data2="${(q)3}" __data3="${(q)4}" __data4="${(q)5}" __text="$6" __handler="$7"
    local __var_name="${8:-reply}"
    local -a __output

    local pfx=""
    [[ -n "$__handler" ]] && {
        [[ $__handler = *internal* ]] && pfx="zuiiaction" || pfx="zuiaction"
        ZUI[$pfx$__id]="$__handler"
    }

    # Quote only text, not codes
    __text="${__text//(#b)([^$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\031'$'0\037']##)/${(q)match[1]}}"

    __output=( "${(P@)__var_name}" $'\01'"$pfx$__id"$'\01'"$__data1"$'\01'"$__data2"$'\01'"$__data3"$'\01'"$__data4"$'\02'"[${__text}]"$'\02' )

    unset pfx __id __data1 __data2 __data3 __data4 __text __handler
    : ${(PA)__var_name::=${__output[@]}}
}

# Appends anchor hyperlink into "reply" output array
# (or to array given by name via $8).
#
# Arguments are initially the same as in -zui_stdlib_\
# button, except:
#
# - the first data argument (data1, $2) needs to be
# index of line to jump to,
#
# - you normally also want to pass module number as
#   data2 ($3) if you assign a handler that is shared
#   between modules,
#
# - instead of handler you might use data3 and data4
#   ($4 & $5) as a module regeneration instruction,
#   i.e. pass e.g.: ",mod2_ice1," "arg", to regenerate
#   some module numbered 2, instance 1, with passed
#   user-data "arg".
#
# If handler is external (i.e. doesn't have "internal"
# in its name), then it might also instruct list
# regeneration, by doing reply=( ",mod2_ice1," "arg"),
# for example.
#
# Anchor of which data3 matches ",*," is set to be
# external. If handler has not word "internal" in its
# name then anchor is also set to be external.
#
# Example call:
#    -zui_stdlib_anchor "regen1" "4" "" ",mod1_ice2," "$RANDOM", "[${ZUI[MAGENTA]}Regen${ZUI[MAGENTA_E]}]"
#
# Generator has instance ID (mod and ice) in $1 and $2
# by the design of restart-regeneration loop.  So, this
# instructs to regenerate module 1 instance 2, with no
# handler call, with $RANDOM as generator's argument -
# regeneration user-data. "4" is the line number on
# which cursor will be placed.
#
function -zui_stdlib_anchor() {
    setopt localoptions extendedglob

    local __id="${(q)1}" __data1="${(q)2}" __data2="${(q)3}" __data3="${(q)4}" __data4="${(q)5}" __text="$6" __handler="$7"
    local __var_name="${8:-reply}"

    # Set to some weird line that probably exists,
    # to signal that anchor works, but input line
    # number is incorrect
    [[ "$__data1" != <-> && "$__data1" != <->[-+]<-> ]] && __data1="1+0+0+0"

    # With no handler do only no-restart jumps
    local hpfx="zuiiaction" __pfx="zuianchor"
    [[ -n "$__handler" ]] && {
        [[ $__handler = *internal* ]] || { hpfx="zuiaction"; __pfx="zuieanchor"; }
        ZUI[$hpfx$__id]="$__handler"
        unset hpfx
    } || {
        # Passed a regeneration instruction?
        # This will make link external, i.e.
        # leading to list restart (so, it's
        # "external" to the list; "internal"
        # is ran within single list run).
        [[ "$__data3" = ,*, ]] && __pfx="zuieanchor"
    }

    # Quote only text, not codes
    __text="${__text//(#b)([^$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\031'$'0\037']##)/${(q)match[1]}}"

    local -a __output
    __output=( "${(P@)__var_name}" $'\01'"$__pfx$__id"$'\01'"$__data1"$'\01'"$__data2"$'\01'"$__data3"$'\01'"$__data4"$'\02'"${__text}"$'\02' )
    : ${(PA)__var_name::=${__output[@]}}

    # Store anchor's target line index
    ZUI[$__pfx$__id]="$__data1"
}

# Appends text-field hyperlink into output array (default: reply)
#
# $1 - action ID
# $2 - module idx
# $3 - width parameter (min and max text width - padding with "_")
# $4 - start-index parameter - what part of string to show
# $5 - text parameter - name of parameter holding text
# $6 - data1
# $7 - data2
# $8 - handler (function name)
# $9 - optional output array name (default: reply)
#
function -zui_stdlib_text_field() {
    local __id="${(q)1}" __module_idx="${(q)2}" __width_var="${(q)3}" __sidx_var="${(q)4}" __text_var="${(q)5}" __data1="${(q)6}" __data2="${(q)7}" __handler="$8"
    local __var_name="${9:-reply}"
    local -a __output

    [[ -n "$__handler" ]] && ZUI[zuitfield$__id]="$__handler"

    __output=( "${(P@)__var_name}" $'\032'"zuitfield$__id"$'\032'"$__data1"$'\032'"$__data2"$'\032'"$__module_idx"$'\032'"$__width_var"$'\032'"$__sidx_var"$'\032'"$__text_var"$'\02' )

    unset __id __module_idx __width_var __sidx_var __text_var __data1 __data2 __handler
    : ${(PA)__var_name::=${__output[@]}}
}

# Appends list-box hyperlink into output array (default: reply)
#
# $1 - action ID
# $2 - width parameter (min and max text width - padding with spaces)
# $3 - index parameter - what option is active
# $4 - options parameter - name of parameter holding ";" separated options
# $5 - data1
# $6 - data2
# $7 - data3
# $8 - handler (function name)
# $9 - optional output array name (default: reply)
#
function -zui_stdlib_list_box() {
    local __id="${(q)1}" __width_var="${(q)2}" __idx_var="${(q)3}" __opts_var="${(q)4}" __data1="${(q)5}" __data2="${(q)6}" __data3="${(q)7}" __handler="$8"
    local __var_name="${9:-reply}"
    local -a __output

    [[ -n "$__handler" ]] && ZUI[zuilbox$__id]="$__handler"

    __output=( "${(P@)__var_name}" $'\034'"zuilbox$__id"$'\034'"$__data1"$'\034'"$__data2"$'\034'"$__data3"$'\034'"$__width_var"$'\034'"$__idx_var"$'\034'"$__opts_var"$'\02' )

    unset __id __width_var __idx_var __opts_var __data1 __data2 __data3 __handler
    : ${(PA)__var_name::=${__output[@]}}
}

# Decodes given hyperlink and returns data contained.
# Testable - test to check if hyperlink was correctly
# decoded.
#
# $1 - hyperlink string
# $2 - optional output array name (default: "reply")
#
# $reply[1] - ID (of action)
# $reply[2] - time stamp
# $reply[3] - command
# $reply[4] - active path
# $reply[5] - file
#
function -zui_stdlib_decode_hyperlink() {
    local __var_name="${2:-reply}"
    : ${(PA)__var_name::=}

    if [[ "$1" = (#b)*$'\01'([^$'\01']#)$'\01'([^$'\01']#)$'\01'([^$'\01']#)$'\01'([^$'\01']#)$'\01'([^$'\02']#)$'\02'* ]]; then
        local __id="${match[1]}" __data1="${match[2]}" __data2="${match[3]}" __data3="${match[4]}" __data4="${match[5]}"
        local assgn_str="${__var_name}[1]"
        : ${(P)assgn_str::=${(Q)__id}}
        assgn_str="${__var_name}[2]"
        : ${(P)assgn_str::=${(Q)__data1}}
        assgn_str="${__var_name}[3]"
        : ${(P)assgn_str::=${(Q)__data2}}
        assgn_str="${__var_name}[4]"
        : ${(P)assgn_str::=${(Q)__data3}}
        assgn_str="${__var_name}[5]"
        : ${(P)assgn_str::=${(Q)__data4}}
        return 0
    fi

    return 1
}

# Decodes given text-field and returns data contained.
# Testable - test to check if hyperlink was correctly
# decoded.
#
# $1 - hyperlink string
# $2 - optional output array name (default: "reply")
#
# $reply[1] - ID (of action)
# $reply[2] - module idx
# $reply[3] - width parameter name
# $reply[4] - start-index parameter name
# $reply[5] - text parameter name
# $reply[6] - data1
# $reply[7] - data2
#
function -zui_stdlib_decode_text_field() {
    local __var_name="${2:-reply}"
    : ${(PA)__var_name::=}

    #                        id [1]              data1 [2]           data2 [3]           module index [4]    width_var [5]       sidx_var [6]        text_var [7]            
    if [[ "$1" = (#b)*$'\032'([^$'\032']#)$'\032'([^$'\032']#)$'\032'([^$'\032']#)$'\032'([^$'\032']#)$'\032'([^$'\032']#)$'\032'([^$'\032']#)$'\032'([^$'\02']#)$'\02'* ]]; then
        local __id="${match[1]}" __data1="${match[2]}" __data2="${match[3]}" __module_idx="${match[4]}" __width_var="${match[5]}" __sidx_var="${match[6]}" __param="${match[7]}"
        local assgn_str="${__var_name}[1]"
        : ${(P)assgn_str::=${(Q)__id}}
        assgn_str="${__var_name}[2]"
        : ${(P)assgn_str::=${(Q)__module_idx}}
        assgn_str="${__var_name}[3]"
        : ${(P)assgn_str::=${(Q)__width_var}}
        assgn_str="${__var_name}[4]"
        : ${(P)assgn_str::=${(Q)__sidx_var}}
        assgn_str="${__var_name}[5]"
        : ${(P)assgn_str::=${(Q)__param}}
        assgn_str="${__var_name}[6]"
        : ${(P)assgn_str::=${(Q)__data1}}
        assgn_str="${__var_name}[7]"
        : ${(P)assgn_str::=${(Q)__data2}}
        return 0
    fi

    return 1
}

# Decodes given list-box and returns data contained.
# Testable - test to check if hyperlink was correctly
# decoded.
#
# $1 - hyperlink string
# $2 - optional output array name (default: "reply")
#
# $reply[1] - ID (of action)
# $reply[2] - width parameter name
# $reply[3] - start-index parameter name
# $reply[4] - text parameter name
# $reply[5] - data1
# $reply[6] - data2
# $reply[7] - data3
#
function -zui_stdlib_decode_list_box() {
    local __var_name="${2:-reply}"
    : ${(PA)__var_name::=}

    #                        id [1]              data1 [2]           data2 [3]           data3 [4]           width_var [5]       idx_var [6]        text_var [7]            
    if [[ "$1" = (#b)*$'\034'([^$'\034']#)$'\034'([^$'\034']#)$'\034'([^$'\034']#)$'\034'([^$'\034']#)$'\034'([^$'\034']#)$'\034'([^$'\034']#)$'\034'([^$'\02']#)$'\02'* ]]; then
        local __id="${match[1]}" __data1="${match[2]}" __data2="${match[3]}" __data3="${match[4]}" __width_var="${match[5]}" __idx_var="${match[6]}" __param="${match[7]}"
        local assgn_str="${__var_name}[1]"
        : ${(P)assgn_str::=${(Q)__id}}
        assgn_str="${__var_name}[2]"
        : ${(P)assgn_str::=${(Q)__width_var}}
        assgn_str="${__var_name}[3]"
        : ${(P)assgn_str::=${(Q)__idx_var}}
        assgn_str="${__var_name}[4]"
        : ${(P)assgn_str::=${(Q)__param}}
        assgn_str="${__var_name}[5]"
        : ${(P)assgn_str::=${(Q)__data1}}
        assgn_str="${__var_name}[6]"
        : ${(P)assgn_str::=${(Q)__data2}}
        assgn_str="${__var_name}[7]"
        : ${(P)assgn_str::=${(Q)__data3}}
        return 0
    fi

    return 1
}

# Tries various decoding functions, testable. Returns (in REPLY)
# "1" if hyperlink (anchor, button, raw link), "2" if text field,
# "3" if list-box
#
# $1 - hyperlink
# $2 - output parameter name, for type (default: REPLY)
function -zui_stdlib_decode() {
    local __out="${2:-REPLY}"
    [[ "$1" = *$'\01'* ]] && { -zui_stdlib_decode_hyperlink "$1" && { : ${(P)__out::=1}; return 0; }; }
    [[ "$1" = *$'\032'* ]] && { -zui_stdlib_decode_text_field "$1" && { : ${(P)__out::=2}; return 0; }; }
    [[ "$1" = *$'\034'* ]] && { -zui_stdlib_decode_list_box "$1" && { : ${(P)__out::=3}; return 0; }; }
    : ${(P)__out::=0}
    return 1
}

# Tests if given text is a hyperlink. Returns (in REPLY)
# "1" if plain hyperlink (anchor, button, raw link), "2"
# if text field, "3" if list-box
#
# $1 - hyperlink
# $2 - output parameter name, for type (default: REPLY)
function -zui_stdlib_is_any_hyperlink() {
    local __out="${2:-REPLY}"
    [[ "$1" = *$'\01'* ]] && { -zui_stdlib_is_hyperlink "$1" && { : ${(P)__out::=1}; return 0; }; }
    [[ "$1" = *$'\032'* ]] && { -zui_stdlib_is_text_field "$1" && { : ${(P)__out::=2}; return 0; }; }
    [[ "$1" = *$'\034'* ]] && { -zui_stdlib_is_list_box "$1" && { : ${(P)__out::=3}; return 0; }; }
    : ${(P)__out::=0}
    return 1
}

# Resolves absolute path from current working directory and file path
#
# $1 - current working directory
#
# $2 - file path
#
# $reply[1] - dirname
#
# $reply[2] - basename
#
function -zui_stdlib_resolve_path() {
    local dirpath="$1" filepath="$2"

    local dirpath2="${dirpath/#\~/$HOME}"
    # :a behaves weird, prepends paths, which are not CWD
    [ "${dirpath2[1]}" = "/" ] && dirpath2="${dirpath2:a}"
    local filepath2="${filepath/#\~/$HOME}"
    [ "${filepath2[1]}" = "/" ] && filepath2="${filepath2:a}"

    reply=()
    if [ "${filepath2[1]}" = "/" ]; then
        reply[1]="${filepath2:h}"
        reply[2]="${filepath2:t}"
    else
        local p="$dirpath2/$filepath2"
        [ "${p[1]}" = "/" ] && p="${p:a}"
        reply[1]="${p:h}"
        reply[2]="${p:t}"
    fi
}

# Puts given text on command line – regardless if Zle is active or not
#
# $1 - text to put on command line
#
function -zui_stdlib_to_cmd_line() {
    if zle; then
        zle .kill-buffer
        BUFFER="$1"
        zle .redisplay
        zle .beginning-of-line
    else
        print -zr "$1"
    fi
}

#
# Returns time %H:%M, via datetime or `date` as fallback
#
function -zui_stdlib_get_time() {
    local ts
    ts="$EPOCHSECONDS"
    [[ -z "$ts" || "$ts" = "0" ]] && REPLY="$(date '+%H:%M')" || strftime -s REPLY '%H:%M' "$ts"
}

# Returns date and time
#
# $REPLY - date and time string "Y_m_d_H.M.S"
#
function -zui_stdlib_get_datetime() {
    local ts
    ts="$EPOCHSECONDS"
    [[ -z "$ts" || "$ts" = "0" ]] && REPLY="$(date '+%Y%m%d_%H.%M.%S')" || strftime -s REPLY '%Y%m%d_%H.%M.%S' "$ts"
}

#
# Returns timestamp, via datetime or `date` as fallback
#
function -zui_stdlib_get_timestamp() {
    REPLY="$EPOCHSECONDS"
    [[ -z "$REPLY" ]] && REPLY="$(date +%s)"
}

# Checks if given text is a hyperlink
function -zui_stdlib_is_hyperlink() {
    [[ "$1" = *$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\02']#$'\02'[^$'\02']#$'\02'* ]]
}

# Checks if given text is a text field
function -zui_stdlib_is_text_field() {
    #                 id                data1             data2             module index      width_var         sidx_var          text_var             
    [[ "$1" = *$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\02']#$'\02'* ]]
}

# Checks if given text is a list box
function -zui_stdlib_is_list_box() {
    #                 id                data1             data2             data3             width_var         sidx_var          text_var             
    [[ "$1" = *$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\02']#$'\02'* ]]
}

# Checks if given text has any hyperlinks
# (buttons/anchors, text fields, list boxes)
function -zui_stdlib_has_any_hyperlinks() {
    [[ "$1" = *$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\01']#$'\01'[^$'\02']#$'\02'[^$'\02']#$'\02'* ]] ||
    #                 id                data1             data2             module index      width_var         sidx_var          text_var             
    [[ "$1" = *$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\032']#$'\032'[^$'\02']#$'\02'* ]] ||
    #                 id                data1             data2             data3             width_var         sidx_var          text_var             
    [[ "$1" = *$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\034']#$'\034'[^$'\02']#$'\02'* ]]
}

# Puts given links in a box, i.e. into sequence of lines
# that are limited in length. The sequence is returned
# in reply array. The length of a link is the length of
# its text, i.e. it doesn't include meta-data.
#
# $1 - box width (line length)
# $2 - max box height (i.e. max # of lines)
# $3 - hyperlink 1
# $4 - hyperlink 2
# $5 - ...
#
function -zui_stdlib_pack_hyperlinks_into_box() {
    local width="$1" max_height="$2"
    shift 2

    reply=()
    local hyp_link __text new_line="" tmp pad
    integer idx max_idx="${#}" text_len diff_len now_width=0 now_height=0
    for (( idx=1; idx <= max_idx; idx ++ )); do
        # The box is limited in height
        (( now_height >= max_height )) && break

        hyp_link="${@[idx]}"
        __text="${hyp_link/(#b)$'\01'*$'\02'([^$'\02']#)$'\02'/${match[1]}}"
        text_len="${#__text}"

        # Will hyp_link fit into this line?
        if [ "$now_width" != "0" ]; then
            if (( now_width + text_len + 1 <= width )); then
                now_width+=text_len+1
                new_line+=" $hyp_link"
            else
                # The line will be too long, pad it and store
                # it into the box array without current link
                # – leave the link for next loop run
                pad=""
                (( width-now_width > 0 )) && pad="${(r:width-now_width:: :)pad}"
                # Store the line into the box array
                reply+=( "${new_line}${pad}" )
                now_height+=1
                # Next line – empty
                new_line=""
                now_width=0
                # Repeat processing of current hyp_link
                idx=idx-1
            fi
        else
            if (( text_len <= width )); then
                now_width+=text_len
                new_line+="$hyp_link"
            else
                # Special case: a hyper-link that does
                # not fit even when it's alone in line
                diff_len=$(( ${#__text} - (width-2) ))
                hyp_link="${hyp_link[1,-diff_len-1]}"
                # Store the truncated button into box array
                reply+=( "${hyp_link}.." )
                now_height+=1
                # Next line – empty
                new_line=""
                now_width=0
            fi
        fi
    done

    # Line that wasn't filled and store wasn't triggered
    if [[ -n "$new_line" && "$now_height" -lt "$max_height" ]]; then
        pad=""
        (( width-now_width > 0 )) && pad="${(r:width-now_width:: :)pad}"
        # Store the line into the box array
        reply+=( "${new_line}${pad}" )
    fi

    #local tmp
    #for tmp in "${reply[@]}"; do
    #    echo "| $tmp |" >> /tmp/reply
    #done
}

# Return n-th (z) segment of given text
# $1 - text
# $2 - segment (default is 1)
# $3 - destination variable name (default is "REPLY")
#
# Can use e.g. 'reply[1]' for $3
function -zui_stdlib_get_segment() {
    local -a segs
    segs=( "${(z@)1}" )
    local varname="${3:-REPLY}"
    local index="${2:-1}"
    : ${(P)varname::=${segs[index]}}
}

# Strips formatting codes from text in
# 1, saves result into parameter REPLY
#
# $1 - text to strip codes from
function -zui_stdlib_strip_codes() {
    REPLY="${1//[$'\03'-$'\07'$'\013'-$'\014'$'\016'-$'\031'$'\037']/}"
}

# Modifies how many instances of a module
# should be generated. Regeneration (no
# on-the-fly support) should be called on
# new instances.
#
# $1 - module index
# $2 - new factor
function -zui_stdlib_set_mod_factor() {
    local key="${zuiel_module_hash[(i)${1}_*]}"
    zuiel_module_hash[$key]="$2"
}

# Returns factor of given module
#
# $1 - module index
# $2 - output parameter name (default: REPLY)
function -zui_stdlib_get_mod_factor() {
    local __var_name="${2:-REPLY}" __key="${zuiel_module_hash[(i)${1}_*]}"
    : ${(P)__var_name::=${zuiel_module_hash[$__key]}}
}

# Returns next file to write to in circular buffer set
# of file names <base>.1 <base>.2 ... <base>.<size>
#
# The buffer is ordered according to modification time.
#
# $1 - base of file names in circular buffer
# $2 - maximum number of files in circular buffer
#
function -zui_stdlib_circular_next() {
    setopt localoptions extendedglob

    # Input data
    local base="$1" count="$2"

    # Circular buffers' directory
    local circpath="$ZUI_CONFIG_DIR/var/circular_buffers"
    [[ ! -d "$circpath" ]] && command mkdir -p "$circpath"

    local -a circular_buffer
    circular_buffer=( "$circpath"/"$base".[[:digit:]]##(OmN) )

    if [[ "$count" -gt "${#circular_buffer}" ]]; then
        integer next_index=$(( ${#circular_buffer} + 1 ))
        REPLY="$circpath/${base}.${next_index}"
    else
        REPLY="${circular_buffer[1]}"
    fi

    return 0
}

#
# Returns absolute file paths of given circular buffer.
# They are ordered from most recent to least recent.
#
# No count is obtained, so all files are returned, even
# actually disabled by buffer limit.
#
# $1 - name of the circular buffer
#
function -zui_stdlib_circular_paths() {
    setopt localoptions extendedglob

    # Input data
    local base="$1"

    # Output array
    reply=( )

    # Circular buffers' directory
    local circpath="$ZUI_CONFIG_DIR/var/circular_buffers"
    [[ ! -d "$circpath" ]] && return 1

    reply=( "$circpath"/"$base".[[:digit:]]##(omN) )
}

# This function clears application data
# from $ZUI global hash. To be called at
# exit and at start of zui application

function -zui_stdlib_cleanup() {
    local -a keys
    # Anchors, checkboxes, actions, internal actions
    keys=( ${ZUI[(I)zuianchor*]} ${ZUI[(I)zuieanchor*]} ${ZUI[(I)zuitfield*]} ${ZUI[(I)zuilbox*]}
           ${ZUI[(I)zuiaction*]} ${ZUI[(I)zuiiaction*]} ${ZUI[(I)fly_*]}
           app app_name PROMPT_SUBST INTERACTIVE_COMMENTS GENERATION_TIME

           # zui-list state fields
           CURRENT_IDX FROM_WHAT_IDX_LIST_IS_SHOWN CURRENT_SEGMENT SEARCH_MODE SEARCH_BUFFER UNIQ_MODE TEXT_OFFSET

           # Configuration keys
           text_mode text_mode_ts_
           colorpair colorpair_ts_
           border border_ts_
           border_cp border_cp_ts_
           bold bold_ts_
           status_colorpair status_colorpair_ts_
           status_border status_border_ts_
           status_border_cp status_border_cp_ts_
           status_bold status_bold_ts_
           status_size status_size_ts_
           mark mark_ts_
           altmark altmark_ts_
           mark2 mark2_ts_
           altmark2 altmark2_ts_
           select_mode select_mode_ts_
           text_mode text_mode_ts_
           text_select text_select_ts_
           status_pointer status_pointer_ts_
           log_append log_append_ts_
           log_index log_index_ts_
           log_size log_size_ts_
           log_time_format log_time_format_ts_
           log_colors log_colors_ts_
    )

    [[ -n "${ZUI[app]}" ]] && ZUI[previous_app]="${ZUI[app]}"

    # Serialize?
    if [[ "$1" = serialize* ]]; then
        local dst="${${1#serialize}#:}"
        -zui_stdlib_serialize "${dst:-${ZUI[app]}}"
    fi

    local k
    for k in "${keys[@]}" ${ZUI[(I)my_*]}; do
        unset "ZUI[$k]"
    done

    (( ${+functions[-zui-standard-global-anchors-callback]} )) && unfunction -- -zui-standard-global-anchors-callback
    (( ${+functions[-zui-standard-status-callback]} )) && unfunction -- -zui-standard-status-callback
    (( ${+functions[-zui-standard-text-select-callback]} )) && unfunction -- -zui-standard-text-select-callback

    # Deserialize?
    if [[ "$1" = deserialize* ]]; then
        local src="${${1#deserialize}#:}"
        -zui_stdlib_deserialize "${src:-${ZUI[app]}}"
    fi
}

# Stores my_* keys of ZUI hash into
# "serialized_${ZUI[app]}" key, which
# can be read with *deserialize() call
function -zui_stdlib_serialize() {
    local dst="${1:-${ZUI[app]}}"

    local -a skeys
    skeys=( ${ZUI[(I)my_*]} CURRENT_IDX FROM_WHAT_IDX_LIST_IS_SHOWN CURRENT_SEGMENT SEARCH_MODE SEARCH_BUFFER UNIQ_MODE TEXT_OFFSET )

    local k out
    for k in "${skeys[@]}"; do
        (( ${+ZUI[$k]} )) && out+="${(q)k} ${(q)ZUI[$k]} "
    done

    ZUI[serialized_$dst]="${out% }"
}

# Reads ZUI[serialized_${ZUI[app]}] and maps
# the content onto ZUI keys, normally my_*
# keys. Use this to restore application state
# after exit and consecutive start.
function -zui_stdlib_deserialize() {
    local src="${1:-${ZUI[app]}}"

    local -a data
    data=( "${(Q@)${(z@)ZUI[serialized_$src]}}" )

    if (( ${#data} % 2 == 0 && ${#data} > 0 )); then
        ZUI+=( "${data[@]}" )
        unset "ZUI[serialized_$src]"
    fi
}

# Use this to quickly load variables:
#
# - mod${midx}_ice${iidx}_global_index
# - mod${midx}_ice${iidx}_size
#
# into parameters given by names.
#
# Has default target parameters' names
# (REPLY & REPLY2), this might lead to
# silent errors, but I prefer that to
# error-revealing crash.. Hm..
#
# $1 - module index
# $2 - instance index
# $3 - output parameter name for global index
# $4 - output parameter name for size
function -zui_stdlib_load_global_index_and_size() {
    local tmp var_name
    3=${2:-REPLY}
    4=${3:-REPLY2}

    var_name="mod${1}_ice${2}_global_index"
    [[ "${(P)+var_name}" = "0" ]] && return 1

    # Global index
    tmp="${(P)var_name}"
    : ${(P)3::=$tmp}

    # Size
    var_name="mod${1}_ice${2}_size"
    tmp="${(P)var_name}"
    : ${(P)4::=$tmp}

    return 0
}

# Resets parameters reply{,2..5}
function -zui_stdlib_reset_replies() {
    local var_name="reply"
    : ${(PA)var_name::=}
    var_name="reply2"
    : ${(PA)var_name::=}
    var_name="reply3"
    : ${(PA)var_name::=}
    var_name="reply4"
    : ${(PA)var_name::=}
}

# Internal action can call this function in
# order to replace module with new version.
# But see call -zui_stdlib_fly_mod_regen.
#
# It uses parameters reply{,2..5} normally
# returned from a module generator. It covers
# calls to multiple submit functions:
#
# - -zui_stdlib_submit_list_update
# - -zui_stdlib_submit_nonselectables
# - -zui_stdlib_submit_hops
# - -zui_stdlib_submit_lanchors
#
# $1 - module index
# $2 - instance index
function -zui_stdlib_submit_fly_from_gen_replies() {
    local mod="$1" ice="$2" global_index previous_size

    # Get global index and previous size. We reach for
    # prev_mod${mod}_ice${ice}_size parameter because here
    # we submit what means outside code that ran generator
    # also probably mapped new replies to non-prev parameters
    var_name="mod${mod}_ice${ice}_global_index"
    global_index="${(P)var_name}"
    var_name="prev_mod${mod}_ice${ice}_size"
    previous_size="${(P)var_name}"

    -zui_stdlib_submit_list_update "$mod" "$ice" "$global_index" "$(( global_index + previous_size - 1 ))" "${reply[@]}"
    -zui_stdlib_submit_nonselectables "${reply2[@]}"
    -zui_stdlib_submit_hops "${reply3[@]}"
    -zui_stdlib_submit_lanchors "${reply4[@]}"
}

# Internal action can call this function in
# order to replace part of list with new text.
#
# $1 - module index, can be empty for stray list update
# $2 - instance index, can be empty as above
# $3 - beginning line number of area to replace
# $4 - end line number of area to replace
# $5, $6, ... - new elements to replace lines $1..$2
function -zui_stdlib_submit_list_update() {
    integer size=$(( $4 - $3 + 1 ))
    4=$size
    ZUI[fly_update]="${(j: :)${(q)@}}"
}

# Internal action can call this function when
# replacing part of list to provide new hops,
# by submitting local indices. They will be
# automatically translated to global indices.
#
# $1, $2, ... - local indices of hops in the
#               substituted fragment
function -zui_stdlib_submit_hops() {
    ZUI[fly_hops]="${(j: :)${(q)@}}"
}

# Internal action can call this function when
# replacing part of list to provide new local
# indices that are non-selectable. They will
# be translated to global indices.
#
# $1, $2, ... - local indices of nonselectables
#               in the substituted fragment
function -zui_stdlib_submit_nonselectables() {
    ZUI[fly_nonselectables]="${(j: :)${(q)@}}"
}

# Internal action can call this function when
# replacing part of list to provide new local
# anchors (their IDs). Their indices (stored
# in $ZUI) will be globalized.
#
# $1, $2, ... - IDs of anchors to be globalized
function -zui_stdlib_submit_lanchors() {
    ZUI[fly_lanchors]="${(j: :)${(q)@}}"
}

# Deserializes on-the-fly update package.
# To be used rather only internally.
#
# $1 - the package
# $2 - optional target parameter name
function -zui_stdlib_decode_list_update() {
    local -a __segments
    [[ -n "$1" ]] && __segments=( "${(z@)1}" ) || __segments=( "" "" 0 0 )
    local __var_name="${2-reply}"

    : ${(PA)__var_name::="${(Q)__segments[@]}"}
}

# Deserializes on-the-fly hops substitution.
# For internal usage.
#
# $1 - the hops' package
# $2 - optional target parameter name
function -zui_stdlib_decode_hops() {
    local -a __hops
    [[ -n "$1" ]] && __hops=( "${(z@)1}" ) || __hops=( )
    local __var_name="${2-reply}"
    : ${(PA)__var_name::=${(Q)__hops[@]}}
}

# Deserializes on-the-fly nonselectables
# substitution. For internal usage.
#
# $1 - the nonselectables' package
# $2 - optional target parameter name
function -zui_stdlib_decode_nonselectables() {
    local -a __nonselectables
    [[ -n "$1" ]] && __nonselectables=( "${(z@)1}" ) || __nonselectables=( )
    local __var_name="${2-reply}"
    : ${(PA)__var_name::="${(Q)__nonselectables[@]}"}
}

# Deserializes on-the-fly local anchors.
# For internal usage.
#
# $1 - the anchors' package
# $2 - optional target parameter name
function -zui_stdlib_decode_lanchors() {
    local -a __lanchors
    [[ -n "$1" ]] && __lanchors=( "${(z@)1}" ) || __lanchors=( )
    local __var_name="${2-reply}"
    : ${(PA)__var_name::="${(Q)__lanchors[@]}"}
}

# Maps reply{,2..4} parameters onto module
# parameters:
#    mod${midx}_ice${iidx}_output mod${midx}_ice${iidx}_nonselectables
#    mod${midx}_ice${iidx}_hops mod${midx}_lice${iidx}_anchors
#    mod${midx}_ice${iidx}_size
#
# $1 - module index
# $2 - instance index
function -zui_stdlib_map_replies() {
    local var_name
    var_name="mod${1}_ice${2}_output"
    : ${(PA)var_name::="${reply[@]}"}
    var_name="mod${1}_ice${2}_size"
    : ${(PA)var_name::=${#reply}}
    var_name="mod${1}_ice${2}_nonselectables"
    : ${(PA)var_name::="${reply2[@]}"}
    var_name="mod${1}_ice${2}_hops"
    : ${(PA)var_name::="${reply3[@]}"}
    var_name="mod${1}_ice${2}_lanchors"
    : ${(PA)var_name::="${reply4[@]}"}
}

# Appends module_${1}_lanchors into array
# given by name
#
# $1 - module index
# $2 - instance index
# $3 - target array name
function -zui_stdlib_gather_lanchors() {
    local __var_name1="mod${1}_ice${2}_lanchors" __var_name2="${3-reply}"
    if [[ -z "$1" || -z "$2" ]]; then
        echo "-zui_stdlib_gather_lanchors must obtain module and instance indices"
        return 1
    fi

    # Append and store
    local -a __output
    __output=( "${(P@)__var_name2}" "${(P@)__var_name1}" )

    : ${(PA)__var_name2::=${__output[@]}}
}

# Loads variable from configuration if it's older than
# e.g.  2 seconds. The point is: I expect users to not
# always manage ZUI hash well: forgot to call *cleanup,
# not reset ZUI[app], etc. This will be covered here:
# if config field in ZUI is fresh, less than say 2
# seconds old, it means it's probably correctly aimed
# at the ZUI application starting. If it's older, it's
# a stray value from previous app.
#
# This applies only to configuration variables stored in
# ZUI hash ($4 = ZUI\[*\]). Other target variables are
# just being read, without age examination.
#
# $1 - Zstyle variable to load, with "s:" or "b:" prefix
#      for string or boolean
# $2 - default value, 0 or 1 for bools
# $3 - time limit
# $4 - output parameter to fill (name)
function -zui_stdlib_load_config() {
    local __ts=${EPOCHSECONDS:-0}

    local __bool="${${${1##b:*}:+0}:-1}" __default="$2" __cvar="${${1#b:}#s:}" __time_limit="${3:-2}" __var_name="${4:-REPLY}"
    local __key __value
    local -a match mbegin mend

    # Check if current ZUI[...] is fresh
    if [[ "$__var_name" = (#b)ZUI\[(*)\] ]]; then
        __key="${match[1]}_ts_"
        # *_ts_ key in ZUI is older than __time_limit?
        if [[ $(( __ts - __time_limit )) -gt "${ZUI[$__key]:-0}" || "$__ts" -eq 0 ]]; then
            ZUI[$__key]=$__ts
        else
            return 0
        fi
    fi

    # Global ZUI settings
    if (( __bool )); then
        if (( __default )); then
            zstyle -T ":plugin:zui" "$__cvar" && : ${(P)__var_name::=1} || : ${(P)__var_name::=0}
        else
            zstyle -t ":plugin:zui" "$__cvar" && : ${(P)__var_name::=1} || : ${(P)__var_name::=0}
        fi
    else
        zstyle -s ":plugin:zui" "$__cvar" __value || __value="$__default"
        : ${(P)__var_name::=$__value}
    fi

    # Application - specific settings
    [[ -n "${ZUI[app]}" ]] && {
        local __zstyle_path=":plugin:zui:app:${ZUI[app]}"
        if (( __bool )); then
            zstyle -t $__zstyle_path "$__cvar" && : ${(P)__var_name::=1} || zstyle -T $__zstyle_path "$__cvar" || : ${(P)__var_name::=0}
        else
            zstyle -s $__zstyle_path "$__cvar" __value && : ${(P)__var_name::=$__value}
        fi
    }

    return 0
}

# Causes -zui_stdlib_load_config to think
# the configuration variable is freshly
# loaded. Use this when restarting list
# and updating ZUI[config] manually, with
# no Zstyle update
#
# $1, $2 ... – keys in ZUI to update, config
#              variables' names
function -zui_stdlib_refresh_configs() {
    local ts=${EPOCHSECONDS:-0} config
    (( ts == 0 )) && ts=$( date +%s )

    for config in "$@"; do
        (( ${+ZUI[$config]} )) && ZUI[${config}_ts_]=$ts
    done
}

# Stores given ZUI[app] configuration if it is not
# already set by user, i.e. if given Zstyle is empty,
# it is then set to given value, so that ZUI will
# read it as the application default, overriding ZUI
# global default.
#
# $1 - Zstyle variable to write, with "s:" or "b:" prefix
#      for string or boolean
# $2 - value to write, 0 or 1 for bools
#
# Returns 0 if written, 1 if Zstyle was already set
function -zui_stdlib_store_default_app_config() {
    local cvar="${${1#b:}#s:}" value="$2" bool="${${${1##b:*}:+0}:-1}"
    local zstyle_path=":plugin:zui:app:${ZUI[app]}" tmp
    integer isset

    # Establish if already set
    if (( bool )); then
        # Lets keep this as a fine piece of logic
        if zstyle -t "$zstyle_path" "$cvar"; then
            isset=1
        else
            zstyle -T "$zstyle_path" "$cvar" && isset=0 || isset=1
        fi
    else
        zstyle -s "$zstyle_path" "$cvar" tmp && isset=1 || isset=0
    fi

    # Store if not set
    if (( isset == 0 )); then
        zstyle "$zstyle_path" "$cvar" "$value"
        return 0
    else
        return 1
    fi
}

# Returns true if the "default" color
# can be used with current Zsh/zcurses
function -zui_stdlib_has_default_color() {
    (( ${+zcurses_colors} )) || return 2
    [[ -z "${zcurses_colors[(r)default]}" ]] && return 1
    autoload is-at-least
    is-at-least 2>/dev/null 5.3 && return 0
    return 1
}

# Appends given message to ZUI_MESSAGES
#
# $1 - message type
# $2 - timestamp
# $3, $4, ... - message bits / lines
function -zui_stdlib_add_message() {
    local tpe="$1" ts="${2:-$(date +%s)}" timestr=""

    # Clean messages on app mismatch
    [[ "${ZUI[app]}" != "${ZUI[messages_app]}" ]] && {
        ZUI_MESSAGES=()
        ZUI[message_count]=0
        ZUI[messages_app]="${ZUI[app]}"
    }

    if [[ -n "${ZUI[log_time_format]}" ]]; then
        if (( ${+builtins[strftime]} )); then
            strftime -s timestr "${ZUI[log_time_format]}" "$ts"
        else
            # Slow and not respecting $ts fallback
            # but will rescue users with weird zsh
            timestr=$(date "+${ZUI[log_time_format]}")
        fi
    fi

    # Clean space-only elements
    set -- "${@[3,-1]/(#s)[[:space:]]##(#e)/}"

    integer index msg_len=0
    for (( index = 1; index <= ${#}; index ++ )); do
        msg_len+=${#@[index]}
    done

    ZUI_MESSAGES+=( "${(q)msg_len} ${(q)tpe} ${(q)ts} ${(q)timestr} ${(j: :)${(q)@}}" )
    (( ++ ZUI[message_count] ))

    # House-keeping
    (( ${#ZUI_MESSAGES} >= ZUI[log_size] + 10 )) && { ZUI_MESSAGES=( "${(@)ZUI_MESSAGES[1+10,-1]}" ); }
}

# Submits on-the-fly module update. Needs
# generator to run and module index. The
# id parameter is unused
#
# $1 - name of generator function
# $2 - module's index
# $3 - instance index
# $4, $5, ... - additional arguments for
#      the generator
-zui_stdlib_fly_mod_regen() {
    local generator="$1" mod="$2" ice="$3"

    shift 3

    -zui_stdlib_reset_replies

    "$generator" "$mod" "$ice" "$@"

    # Setting the following will also pass the new
    # content to regeneration-path. I.e. you can
    # do restart-update (not on-the-fly update) and
    # module "$module" will still have data from
    # this *_regenerate call. Note that the data
    # will be overwritten if restart-update will
    # regenerate "$module".
    -zui_stdlib_map_replies "$mod" "$ice"

    # No typical saving of any newly created local
    # anchors. There is no regeneration loop (i.e.
    # it is on-the-fly update) and placing anchors
    # is handled in zui-list.
    # -zui_stdlib_gather_lanchors regen_lanchors

    # Submit on-the-fly list update. The same data
    # as in -zui_stdlib_map_replies.
    -zui_stdlib_submit_fly_from_gen_replies "$mod" "$ice"

    # No output from this function
    -zui_stdlib_reset_replies
}

# Maps boolean values of expressions given in $1
# (string separated by ';') to parameters given
# via names in $2 (separated by ';'). For true,
# $3 is assigned to corresponding parameter, $4
# for false.
#
# If $1 contains [[ or ((, it is evaluated. If
# it is a positive number or zero, then it is
# treated as direct bool value. Otherwise it's
# treated as parameter name, and boolean value
# of the parameter (it has to be positive number
# or zero) is examined.
#
# -zui_stdlib_map_bools "1;[[ a = b ]];ZUI[text_select]" \
#                       "color1;color2;color3" $red $white
#
function -zui_stdlib_map_bools() {
    local __exp="$1" __pm="$2" __tre="$3" __fse="$4"

    local -a __exps __pms
    __exps=( "${(@s:;:)__exp}" )
    __pms=( "${(@s:;:)__pm}" )

    integer __index __size=${#__pms}
    for (( __index=1; __index <= __size; ++ __index )); do
        __exp="${__exps[__index]}"
        __pm="${__pms[__index]}"
        [[ -z "${__exp##[[:space:]]##}" || -z "${__pm##[[:space:]]##}" ]] && continue
        if [[ "$__exp" = <-> ]] then
            (( $__exp )) && : ${(P)__pm::=$__tre} || : ${(P)__pm::=$__fse}
        elif [[ "$__exp" != *\[\[* && "$__exp" != *\(\(* ]]; then
            [[ "${(P)__exp}" != <-> || "${(P)__exp}" = 0## ]] && : ${(P)__pm::=$__fse} || : ${(P)__pm::=$__tre}
        else
            eval "$__exp" && : ${(P)__pm::=$__tre} || : ${(P)__pm::=$__fse}
        fi
    done
}
# vim:ft=zsh
