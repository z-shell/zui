emulate -L zsh

zmodload zsh/curses

setopt typesetsilent extendedglob

# Compute first to show index - exact page
-zui_listin_compute_first_to_show_idx() {
    from_what_idx_list_is_shown=0+((current_idx-1)/page_height)*page_height+1
}

# Conditional, fully robust page-to-show computation
-zui_listin_compute_exact_page_if_needed() {
    # Fallback: in case of any problems compute exact page
    if [[ "$from_what_idx_list_is_shown" -lt "1" ||
        "$from_what_idx_list_is_shown" -gt "$last_element" ]]
    then
        from_what_idx_list_is_shown=0+((current_idx-1)/page_height)*page_height+1
    fi
}

# Compute first to show index - page is
# scrolled to center to show given index
-zui_listin_compute_first_to_show_idx_center() {
    from_what_idx_list_is_shown=current_idx-page_height/2
    -zui_listin_compute_exact_page_if_needed
}

# Calling this function means passing information
# that we move up in the list (to lower index)
# This means we can move page start as few as 7
# elements up.
-zui_listin_compute_first_to_show_idx_up_many() {
    if [[ "$current_idx" -lt "$from_what_idx_list_is_shown" ||
        "$current_idx" -gt "$(( from_what_idx_list_is_shown + page_height -1 ))" ]]
    then
        from_what_idx_list_is_shown=from_what_idx_list_is_shown-7
        -zui_listin_compute_exact_page_if_needed
    fi
}

# Like above, but in opposite direction
-zui_listin_compute_first_to_show_idx_down_many() {
    if [[ "$current_idx" -lt "$from_what_idx_list_is_shown" ||
        "$current_idx" -gt "$(( from_what_idx_list_is_shown + page_height -1 ))" ]]
    then
        from_what_idx_list_is_shown=from_what_idx_list_is_shown+7
        -zui_listin_compute_exact_page_if_needed
    fi
}

# Searches for hyperlink in current line,
# sets current_segment to first link found
-zui_listin_search_for_hyperlink() {
    local -a segments
    segments=( "${(Pz@)list_var_current}" )

    # Hide global $nseg
    local nseg="${#segments}"

    [[ "$current_segment" -gt "$nseg" ]] && current_segment="$nseg"
    [[ "$current_segment" -le 0 ]] && current_segment="1"

    integer left=current_segment right=current_segment

    # Left
    while ! -zui_stdlib_is_hyperlink "${segments[left]}" && ! -zui_stdlib_is_text_field "${segments[left]}"; do
        (( -- left ))
        [[ "$left" -le 0 ]] && break
    done

    # Right
    while ! -zui_stdlib_is_hyperlink "${segments[right]}" && ! -zui_stdlib_is_text_field "${segments[right]}"; do
        (( ++ right ))
        [[ "$right" -gt "$nseg" ]] && break
    done

    # Choose smaller distance
    if (( left >= 1 && right <= nseg && (current_segment - left) <= (right - current_segment) )); then
        current_segment=left
    elif (( right <= nseg )); then
        current_segment=right
    elif (( left >= 1 )); then
        current_segment=left
    fi
}

# Testable, searches for next (excluding current
# one) hyperlink, returns 1 if not found, 0 if
# found (this implies update of current_segment)
#
# $1 - direction: 0 - left, other - right
-zui_listin_set_next_hyperlink() {
    local -a segments
    segments=( "${(Pz@)list_var_current}" )

    # Hide global $nseg
    local nseg="${#segments}"

    [[ "$current_segment" -gt "$nseg" ]] && current_segment="$nseg"
    [[ "$current_segment" -le 0 ]] && current_segment="1"

    integer left=current_segment right=current_segment

    # Left
    [[ "$1" = "0" ]] && {
        while ! -zui_stdlib_is_hyperlink "${segments[left]}" && ! -zui_stdlib_is_text_field "${segments[left]}" || (( left == current_segment )); do
            (( -- left ))
            [[ "$left" -le 0 ]] && break
        done

        if (( left >= 1 )); then
            current_segment=left
            return 0
        fi
    } || {
        # Right
        while ! -zui_stdlib_is_hyperlink "${segments[right]}" && ! -zui_stdlib_is_text_field "${segments[right]}" || (( right == current_segment )); do
            (( ++ right ))
            [[ "$right" -gt "$nseg" ]] && break
        done

        if (( right <= nseg )); then
            current_segment=right
            return 0
        fi
    }

    return 1
}

typeset -ga reply
reply=( -1 '' )
integer current_idx="$1"
integer current_segment="$2"
integer from_what_idx_list_is_shown="$3"
integer page_height="$4"
integer page_width="$5"
integer last_element="$6"
integer nseg="$7"
integer hscroll="$8"
local key="$9"
integer search="$10"
local buffer="$11"
integer uniq_mode="$12"
integer disable_search="$13"
local list_var_current="${14}[\$current_idx]"

local text
local -a wrk_reply

# Trigger nearest hyperlink searching,
# even when ZUI[text_mode] is 1
integer search_for_hyperlink=0

#
# Listening for input
#

if [[ -n "${ZUI[current_tfield]}" ]]; then
    -zui_stdlib_get_segment "${(P)list_var_current}" "$current_segment"
    if -zui_stdlib_decode_text_field "$REPLY" wrk_reply; then
        case "$key" in
            ($'\n')
                ZUI[current_tfield]=""
                ZUILIST_REGENERATE_LIST="2" # regenerate only display list
                reply=( $current_idx TFIELD_LEFT )
                ;;
            ($'\E')
                : ${(P)wrk_reply[4]::=${ZUI[current_tfield_initial_sidx]}}
                : ${(P)wrk_reply[5]::=${ZUI[current_tfield_initial_data]}}
                ZUI[current_tfield]=""
                reply=( $current_idx TFIELD_CANCELLED )
                ;;
            (DOWN|NPAGE)
                text="${(P)wrk_reply[3]}"
                (( text = text > 5 ? text - 1 : text ))
                : ${(P)wrk_reply[3]::=$text}
                ;;
            (UP|PPAGE)
                text="${(P)wrk_reply[3]}"
                (( text ++ ))
                : ${(P)wrk_reply[3]::=$text}
                ;;
            (HOME)
                ZUI[cursor_x]="${ZUI[current_tfield_cidx_start]}"
                : ${(P)wrk_reply[4]::=1}
                ;;
            (END)
                ZUI[cursor_x]="${ZUI[current_tfield_cidx_end]}"
                text="${(P)wrk_reply[5]}"
                text=$(( ${#text} - ${(P)wrk_reply[3]} + 1 ))
                : ${(P)wrk_reply[4]::=$text}
                ;;
            (LEFT)
                if (( ZUI[cursor_x] > ZUI[current_tfield_cidx_start] )); then
                    (( -- ZUI[cursor_x] ))
                else
                    text="${(P)wrk_reply[4]}"
                    (( text = text > 1 ? text - 1 : text ))
                    : ${(P)wrk_reply[4]::=$text}
                fi
                ;;
            (RIGHT)
                if (( ZUI[cursor_x] < ZUI[current_tfield_cidx_end] )); then
                    (( ++ ZUI[cursor_x] ))
                else
                    # Dont advance cursor when we're at right boundary, advance
                    # index so that whole string is shown. Also, allow further
                    # advancement of the index, to scroll string left.
                    # string index + width - 1 < #string + width/2
                    if (( ${(P)wrk_reply[4]} + ${(P)wrk_reply[3]} - 1 < ${(P)#wrk_reply[5]} + ${(P)wrk_reply[3]} / 2 )); then
                        text="${(P)wrk_reply[4]}"
                        (( ++ text ))
                        : ${(P)wrk_reply[4]::=$text}
                    fi
                fi
                ;;
            ($'\b'|$'\C-?'|BACKSPACE)
                if (( ZUI[cursor_x] > ZUI[current_tfield_cidx_start] )); then
                    text="${(P)wrk_reply[5]}"
                    text[${ZUI[current_tfield_instr_idx]}]=""
                    : ${(P)wrk_reply[5]::=$text}
                    (( -- ZUI[cursor_x] ))
                fi
                ;;
            (DC)
                if (( ZUI[cursor_x] < ZUI[current_tfield_cidx_end] )); then
                    text="${(P)wrk_reply[5]}"
                    text[${ZUI[current_tfield_instr_idx]}+1]=""
                    : ${(P)wrk_reply[5]::=$text}
                fi
                ;;
            (??*|$'\t')
                ;;
            (*)
                text="${(P)wrk_reply[5]}"
                if (( ZUI[current_tfield_instr_idx] )); then
                    text[${ZUI[current_tfield_instr_idx]}]="${text[${ZUI[current_tfield_instr_idx]}]}$key"
                    : ${(P)wrk_reply[5]::=$text}

                    # Scroll text right if string protrudes from
                    # right boundary of text field
                    # #string > string index + width - 1
                    if (( ${(P)#wrk_reply[5]} > ${(P)wrk_reply[4]} + ${(P)wrk_reply[3]} - 1 )); then
                        text="${(P)wrk_reply[4]}"
                        (( ++ text ))
                        : ${(P)wrk_reply[4]::=$text}
                    else
                        (( ++ ZUI[cursor_x] ))
                    fi
                else
                    # Prepend
                    text="$key$text"
                    : ${(P)wrk_reply[5]::=$text}
                    (( ++ ZUI[cursor_x] ))
                fi
                ;;
        esac

        -zui_syslib_get_tfield_cursor_boundaries 'ZUI[current_tfield_cidx_start]' 'ZUI[current_tfield_cidx_end]' "${(P)list_var_current}" "${wrk_reply[1]}"
        (( ZUI[cursor_x] = ZUI[cursor_x] > ZUI[current_tfield_cidx_end] ? ZUI[current_tfield_cidx_end] : ZUI[cursor_x] ))
        ZUI[current_tfield_instr_idx]=$(( ${(P)wrk_reply[4]} + ZUI[cursor_x] - ZUI[current_tfield_cidx_start] - 1 ))
    else
        ZUI[current_tfield]=""
    fi
elif [[ "$search" = "0" ]]; then

case "$key" in
    (UP|k)
        # Are there any elements before the current one?
        [[ "$current_idx" -gt 1 ]] && current_idx=current_idx-1
        while [[ -z "${(P)list_var_current}" && "$current_idx" -gt 1 ]]; do
            current_idx=current_idx-1
        done
        -zui_listin_compute_first_to_show_idx_up_many
        ;;
    (DOWN|j)
        # Are there any elements after the current one?
        [[ "$current_idx" -lt "$last_element" ]] && current_idx=current_idx+1
        while [[ -z "${(P)list_var_current}" && "$current_idx" -lt "$last_element" ]]; do
            current_idx=current_idx+1
        done
        -zui_listin_compute_first_to_show_idx_down_many
        ;;
    ($'\C-P')
        [[ "$current_idx" -gt 1 ]] && current_idx=current_idx-1
        while [[ -z "${(P)list_var_current}" && "$current_idx" -gt 1 ]]; do
            current_idx=current_idx-1
        done
        -zui_listin_compute_first_to_show_idx_center
        ;;
    ($'\C-N')
        # Are there any elements after the current one?
        [[ "$current_idx" -lt "$last_element" ]] && current_idx=current_idx+1
        while [[ -z "${(P)list_var_current}" && "$current_idx" -lt "$last_element" ]]; do
            current_idx=current_idx+1
        done
        -zui_listin_compute_first_to_show_idx_center
        ;;
    (PPAGE|$'\b'|$'\C-?'|BACKSPACE)
        current_idx=current_idx-page_height
        [[ "$current_idx" -lt 1 ]] && current_idx=1;
        -zui_listin_compute_first_to_show_idx
        ;;
    (NPAGE|" ")
        current_idx=current_idx+page_height
        [[ "$current_idx" -gt "$last_element" ]] && current_idx=last_element;
        -zui_listin_compute_first_to_show_idx
        ;;
    ($'\C-U')
        current_idx=current_idx-page_height/2
        [[ "$current_idx" -lt 1 ]] && current_idx=1;
        -zui_listin_compute_first_to_show_idx
        ;;
    ($'\C-D')
        current_idx=current_idx+page_height/2
        [[ "$current_idx" -gt "$last_element" ]] && current_idx=last_element;
        -zui_listin_compute_first_to_show_idx
        ;;
    (HOME|g)
        current_idx=1
        -zui_listin_compute_first_to_show_idx
        ;;
    (END|G)
        current_idx=last_element
        -zui_listin_compute_first_to_show_idx
        ;;
    ($'\n'|ENTER)
        # Is that element selectable?
        # Check for this only when there is no search
        if [[ "$ZUILIST_SEARCH_BUFFER" != "" || "$ZUILIST_IS_UNIQ_MODE" -eq 1 ||
            ${ZUILIST_NONSELECTABLE_ELEMENTS[(r)$current_idx]} != $current_idx ]]
        then
            # Check if we are at hyperlink. Only then allow selection
            -zui_stdlib_get_segment "${(P)list_var_current}" "$current_segment"

            local -a data
            reply=( )
            if -zui_stdlib_decode_hyperlink "$REPLY"; then
                if [[ "${reply[1]}" = zuianchor* || "${reply[1]}" = zuiiaction* ]]; then
                    # This is to run internal action,
                    # i.e. action without leaving list
                    reply=( $current_idx HYPERLINK )
                else
                    # This hyperlink path is through
                    # quitting list and restarting it
                    reply=( $current_idx SELECT )
                fi
            elif -zui_stdlib_decode_text_field "$REPLY"; then
                ZUI[current_tfield]="${reply[1]}"
                ZUI[current_tfield_initial_sidx]="${(P)reply[4]}"
                ZUI[current_tfield_initial_data]="${(P)reply[5]}"
                -zui_syslib_get_tfield_cursor_boundaries 'ZUI[current_tfield_cidx_start]' 'ZUI[current_tfield_cidx_end]' "${(P)list_var_current}" "${reply[1]}"
                ZUI[cursor_y]=$(( ZUILIST_CURRENT_IDX - ZUILIST_FROM_WHAT_IDX_LIST_IS_SHOWN + 1 ))
                ZUI[cursor_x]=$(( ZUI[current_tfield_cidx_end] ))
                ZUI[current_tfield_instr_idx]=$(( ${(P)reply[4]} + ZUI[cursor_x] - ZUI[current_tfield_cidx_start] - 1 ))
                reply=( $current_idx HYPERLINK )
            else
                # Selecting non-hyperlink is disallowed?
                (( ${ZUI[text_select]} )) && reply=( $current_idx SELECT ) || reply=( -1 '' )
            fi
        fi
        ;;
    (q|Q)
        reply=( -1 QUIT )
        ;;
    (/)
        if [[ "$disable_search" = "0" ]]; then
            search=1
            -zui_list_cursor_visibility "status" 1
        fi
        ;;
    ($'\C-L')
        reply=( -1 REDRAW )
        ;;
    (\])
        if [[ "${ZUILIST_ENABLED_EVENTS[(r)BR_MOVE_RIGHT]}" = "BR_MOVE_RIGHT" ]]; then
            reply=( "$current_segment" "BR_MOVE_RIGHT" )
        else

        [[ "${(t)ZUILIST_HOP_INDICES}" = "array" || "${(t)ZUILIST_HOP_INDICES}" = "array-local" ]] &&
        [[ -z "$ZUILIST_SEARCH_BUFFER" ]] && [[ "$ZUILIST_IS_UNIQ_MODE" -eq 0 ]] &&
        for idx in "${(n)ZUILIST_HOP_INDICES[@]}"; do
            if [[ "$idx" -gt "$current_idx" ]]; then
                current_idx=$idx
                -zui_listin_compute_first_to_show_idx_center
                break
            fi
        done

        fi
        ;;
    (\[)
        if [[ "${ZUILIST_ENABLED_EVENTS[(r)BR_MOVE_LEFT]}" = "BR_MOVE_LEFT" ]]; then
            reply=( "$current_segment" "BR_MOVE_LEFT" )
        else

        [[ "${(t)ZUILIST_HOP_INDICES}" = "array" || "${(t)ZUILIST_HOP_INDICES}" = "array-local" ]] &&
        [[ -z "$ZUILIST_SEARCH_BUFFER" ]] && [[ "$ZUILIST_IS_UNIQ_MODE" -eq 0 ]] &&
        for idx in "${(nO)ZUILIST_HOP_INDICES[@]}"; do
            if [[ "$idx" -lt "$current_idx" ]]; then
                current_idx=$idx
                -zui_listin_compute_first_to_show_idx_center
                break
            fi
        done

        fi
        ;;
    ('<'|'{')
        hscroll=hscroll-7
        [[ "$hscroll" -lt 0 ]] && hscroll=0
        ;;
    ('>'|'}')
        hscroll+=7
        ;;
    (LEFT|'h'|BTAB)
        if [[ "$key" = "BTAB" && ${ZUILIST_NONSELECTABLE_ELEMENTS[(r)$current_idx]} = $current_idx ]]; then
            [[ "$current_idx" -gt "1" ]] && {
                current_idx=current_idx-1
                current_segment="100"
            }
            while [[ -z "${(P)list_var_current}" && "$current_idx" -gt 1 ]]; do
                current_idx=current_idx-1
            done
            -zui_listin_compute_first_to_show_idx_up_many
        else
            # Establish exact right-edge segment
            if [[ "$current_segment" -gt "$nseg" ]]; then
                (( current_segment = nseg ))
                [[ "$current_segment" -le 0 ]] && current_segment=1
            fi

            if [[ "$key" = "BTAB" ]]; then
                if ! -zui_listin_set_next_hyperlink 0; then
                    # No link left in current line - move
                    # one line up, set segment to far-most,
                    # verification at bottom will find the
                    # nearest hyperlink
                    [[ "$current_idx" -gt "1" ]] && {
                        current_idx=current_idx-1
                        current_segment="100"
                        search_for_hyperlink=1
                    }
                    while [[ -z "${(P)list_var_current}" && "$current_idx" -gt 1 ]]; do
                        current_idx=current_idx-1
                    done
                    -zui_listin_compute_first_to_show_idx_up_many
                fi
            else
                # || Search left accepting lack of success
                (( ${ZUI[text_mode]} )) && (( -- current_segment )) || -zui_listin_set_next_hyperlink 0
            fi
        fi
        ;;
    (RIGHT|'l'|$'\t')
        if [[ "$key" = $'\t' && ${ZUILIST_NONSELECTABLE_ELEMENTS[(r)$current_idx]} = $current_idx ]]; then
            [[ "$current_idx" -lt "$last_element" ]] && {
                current_idx=current_idx+1
                current_segment=1
            }
            while [[ -z "${(P)list_var_current}" && "$current_idx" -lt "$last_element" ]]; do
                current_idx=current_idx+1
            done
            -zui_listin_compute_first_to_show_idx_down_many
        else
            if [[ "$key" = $'\t' ]]; then
                # Search hyperlinks right
                if ! -zui_listin_set_next_hyperlink 1; then
                    # Move to next line, set current_segment
                    # to 1, verification at bottom will find
                    # nearest hyperlink if it exists in the
                    # next line
                    [[ "$current_idx" -lt "$last_element" ]] && {
                        current_idx=current_idx+1
                        current_segment="1"
                        search_for_hyperlink=1
                    }
                    while [[ -z "${(P)list_var_current}" && "$current_idx" -lt "$last_element" ]]; do
                        current_idx=current_idx+1
                    done
                    -zui_listin_compute_first_to_show_idx_down_many
                fi
            else
                # || Search right accepting lack of success
                (( ${ZUI[text_mode]} )) && (( ++ current_segment )) || -zui_listin_set_next_hyperlink 1
            fi
            [[ "$current_segment" -gt "$nseg" ]] && current_segment="$nseg"
        fi
        ;;
    (F1|F2|F3|F4)
        reply=( -1 "$key" )
        ;;
    ($'\E')
        buffer=""
        ;;
    (o|$'\C-O')
        uniq_mode=1-uniq_mode
        ;;
    (*)
        ;;
esac

else

case "$key" in
    ($'\n'|ENTER)
        search=0
        -zui_list_cursor_visibility "status" 0
        ;;
    ($'\C-L')
        reply=( -1 REDRAW )
        ;;

    #
    # Slightly limited navigation
    #

    (UP)
        [[ "$current_idx" -gt 1 ]] && current_idx=current_idx-1
        while [[ -z "${(P)list_var_current}" && "$current_idx" -gt 1 ]]; do
            current_idx=current_idx-1
        done
        -zui_listin_compute_first_to_show_idx_up_many
        ;;
    (DOWN)
        [[ "$current_idx" -lt "$last_element" ]] && current_idx=current_idx+1
        while [[ -z "${(P)list_var_current}" && "$current_idx" -lt "$last_element" ]]; do
            current_idx=current_idx+1
        done
        -zui_listin_compute_first_to_show_idx_down_many
        ;;
    ($'\C-P')
        [[ "$current_idx" -gt 1 ]] && current_idx=current_idx-1
        while [[ -z "${(P)list_var_current}" && "$current_idx" -gt 1 ]]; do
            current_idx=current_idx-1
        done
        -zui_listin_compute_first_to_show_idx_center
        ;;
    ($'\C-N')
        # Are there any elements after the current one?
        [[ "$current_idx" -lt "$last_element" ]] && current_idx=current_idx+1
        while [[ -z "${(P)list_var_current}" && "$current_idx" -lt "$last_element" ]]; do
            current_idx=current_idx+1
        done
        -zui_listin_compute_first_to_show_idx_center
        ;;
    (PPAGE)
        current_idx=current_idx-page_height
        [[ "$current_idx" -lt 1 ]] && current_idx=1;
        -zui_listin_compute_first_to_show_idx
        ;;
    (NPAGE)
        current_idx=current_idx+page_height
        [[ "$current_idx" -gt "$last_element" ]] && current_idx=last_element;
        -zui_listin_compute_first_to_show_idx
        ;;
    ($'\C-U')
        current_idx=current_idx-page_height/2
        [[ "$current_idx" -lt 1 ]] && current_idx=1;
        -zui_listin_compute_first_to_show_idx
        ;;
    ($'\C-D')
        current_idx=current_idx+page_height/2
        [[ "$current_idx" -gt "$last_element" ]] && current_idx=last_element;
        -zui_listin_compute_first_to_show_idx
        ;;
    (HOME)
        current_idx=1
        -zui_listin_compute_first_to_show_idx
        ;;
    (END)
        current_idx=last_element
        -zui_listin_compute_first_to_show_idx
        ;;
    (LEFT|BTAB)
        if [[ "$key" = "BTAB" && ${ZUILIST_NONSELECTABLE_ELEMENTS[(r)$current_idx]} = $current_idx ]]; then
            [[ "$current_idx" -gt "1" ]] && {
                current_idx=current_idx-1
                current_segment="100"
            }
            while [[ -z "${(P)list_var_current}" && "$current_idx" -gt 1 ]]; do
                current_idx=current_idx-1
            done
            -zui_listin_compute_first_to_show_idx_up_many
        else
            # Establish exact right-edge segment
            if [[ "$current_segment" -gt "$nseg" ]]; then
                (( current_segment = nseg ))
                [[ "$current_segment" -le 0 ]] && current_segment=1
            fi

            if [[ "$key" = "BTAB" ]]; then
                if ! -zui_listin_set_next_hyperlink 0; then
                    # No link to the left in current line - move
                    # one line up, set segment to far-most, the
                    # verification at bottom will find the nearest
                    # hyperlink
                    [[ "$current_idx" -gt "1" ]] && {
                        current_idx=current_idx-1
                        current_segment="100"
                        search_for_hyperlink=1
                    }
                    while [[ -z "${(P)list_var_current}" && "$current_idx" -gt 1 ]]; do
                        current_idx=current_idx-1
                    done
                    -zui_listin_compute_first_to_show_idx_up_many
                fi
            else
                # || Search left accepting lack of success
                (( ${ZUI[text_mode]} )) && (( -- current_segment )) || -zui_listin_set_next_hyperlink 0
            fi
        fi
        ;;
    (RIGHT|$'\t')
        if [[ "$key" = $'\t' && ${ZUILIST_NONSELECTABLE_ELEMENTS[(r)$current_idx]} = $current_idx ]]; then
            [[ "$current_idx" -lt "$last_element" ]] && {
                current_idx=current_idx+1
                current_segment=1
            }
            while [[ -z "${(P)list_var_current}" && "$current_idx" -lt "$last_element" ]]; do
                current_idx=current_idx+1
            done
            -zui_listin_compute_first_to_show_idx_down_many
        else
            if [[ "$key" = $'\t' ]]; then
                if ! -zui_listin_set_next_hyperlink 1; then
                    # Move to next line, set current_segment
                    # to 1, verification at bottom will find
                    # nearest hyperlink if it exists in the
                    # next line
                    [[ "$current_idx" -lt "$last_element" ]] && {
                        current_idx=current_idx+1
                        current_segment="1"
                        search_for_hyperlink=1
                    }
                    while [[ -z "${(P)list_var_current}" && "$current_idx" -lt "$last_element" ]]; do
                        current_idx=current_idx+1
                    done
                    -zui_listin_compute_first_to_show_idx_down_many
                fi
            else
                # || Search right accepting lack of success
                (( ${ZUI[text_mode]} )) && (( ++ current_segment )) || -zui_listin_set_next_hyperlink 1
            fi
            [[ "$current_segment" -gt "$nseg" ]] && current_segment="$nseg"
        fi
        ;;
    (F1|F2|F3|F4)
        reply=( -1 "$key" )
        ;;
    (F4|F5|F6|F7|F8|F9|F10)
        # ignore
        ;;

    #
    # The input
    #

    ($'\b'|$'\C-?'|BACKSPACE)
        buffer="${buffer%?}"
        ;;
    ($'\C-W')
        [[ "$buffer" = "${buffer% *}" ]] && buffer="" || buffer="${buffer% *}"
        ;;
    ($'\C-K')
        buffer=""
        ;;
    ($'\E')
        buffer=""
        search=0
        -zui_list_cursor_visibility "status" 0
        ;;
    ($'\C-O')
        uniq_mode=1-uniq_mode
        ;;
    (*)
        if [[ $#key == 1 && $((#key)) -lt 31 ]]; then
            # ignore all other control keys
        else
            buffer+="$key"
        fi
        ;;
esac

fi

# Make current_segment point to
# hyperlink, if it exists in line
(( ${ZUI[text_mode]} && search_for_hyperlink == 0 )) || -zui_listin_search_for_hyperlink

reply[3]="$current_idx"
reply[4]="$current_segment"
reply[5]="$from_what_idx_list_is_shown"
reply[6]="$hscroll"
reply[7]="$search"
reply[8]="$buffer"
reply[9]="$uniq_mode"

# vim: set filetype=zsh:
